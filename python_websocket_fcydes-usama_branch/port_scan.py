from concurrent import futures
from sys import flags
import target_validation
import random
from concurrent.futures import ThreadPoolExecutor
import concurrent.futures
from datetime import datetime
import socket
import codecs
import os
import sqlite3
import multiprocessing
import threading
import utilities
from packet_headers import tcp_ip_headers
class PortScan:

    def __init__(self, info_gather, user_id, ws):
        
        self.info_gather = info_gather

        self.packet = tcp_ip_headers.Packet()

        # self.source_host_ip = target_validation.getHostIP(self.info_gather.interface)
        
        self.source_host_ip = ''
        
        self.lock = threading.Lock()

        self.user_id = user_id

        self.ws = ws

        self.ports_status = []

        self.module = 'Port Scanning'

        self.sub_module = ''

    def get_port_service(self, port):
        
        services_db_path = os.getcwd() + '/services.db'

        service = None

        if os.path.exists(services_db_path):
            conn = sqlite3.connect(services_db_path)

            cursor = conn.cursor()

            cursor.execute('''SELECT service from services where port == ? and proto == ?;''', (port, 'tcp',))

            service = cursor.fetchone()

            if service:
                service = service[0]

            else:
                service = 'Unknown'

            conn.commit()

            conn.close()

        return service

    # def add_open_ports_to_results(self, ports_status):
        
    #     self.info_gather.add_ports_to_results(ports_status)

    
    #---------------------------------------------------------------------------------------------------------#
    #                                              Connect Scan                                                   #
    #---------------------------------------------------------------------------------------------------------#
    # def syn_scan_thread(self, target, dest_port):

    #     # source_port = random.randint(9999, 65000)
    #     source_port = 12345
    #     packet_header = self.packet.generateIPHeader(self.source_host_ip, target)+self.packet.generateTCPHeader(source_port, dest_port, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0)
    #     packet_header_hex = (codecs.encode(packet_header, 'hex').decode())
    #     port_num = packet_header_hex[44:48]
    #     sock = socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP)
    #     sock.setsockopt(socket.IPPROTO_IP,socket.IP_HDRINCL,1)
    #     response = self.packet.send_tcp_packet(packet_header, target, port_num, sock)
    #     sock.close()

    #     if response:
    #         hex_response = codecs.encode(response, 'hex').decode()
    #         if hex_response[65:68] == '012':
    #             print(dest_port)
    #             service = self.get_port_service(dest_port)
    #             # print(service)
    #             # self.add_open_ports_to_results(target, dest_port, service)

    # def syn_scan(self, target, ports):

    #     num_of_thread = multiprocessing.cpu_count() * 10

    #     with ThreadPoolExecutor(num_of_thread) as executor:
    #         for port in ports:
    #             executor.submit(self.syn_scan_thread, target, port)

    #---------------------------------------------------------------------------------------------------------#
    #                                              SYN Scan                                                   #
    #---------------------------------------------------------------------------------------------------------#
    def syn_scan_thread_filtered_ports_retransmission(self, target, dest_port):
        
        retransmission_count = 0

        while retransmission_count < 3:

            retransmission_count += 1

            source_port = random.randint(9999, 50000)
            packet_header = self.packet.generateIPHeader(self.source_host_ip, target)+self.packet.generateTCPHeader(source_port, dest_port, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0)
            packet_header_hex = (codecs.encode(packet_header, 'hex').decode())
            port_num = packet_header_hex[44:48]
            sock = socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP)
            sock.setsockopt(socket.IPPROTO_IP,socket.IP_HDRINCL,1)
            response = self.packet.send_tcp_packet(packet_header, target, port_num, sock)
            sock.close()

            if response:
                hex_response = codecs.encode(response, 'hex').decode()
                if hex_response[65:68] == '012':

                    service = self.get_port_service(dest_port)
                    tempDict = dict(port=dest_port, status='open', service=service)

                    return tempDict
                
                elif hex_response[65:68] == '014' or hex_response[65:68] == '004':

                    tempDict = dict(port=dest_port, status='closed', service='None')

                    return tempDict


    def syn_scan_thread(self, target, dest_port):

        tempDict = None
        
        source_port = random.randint(9999, 50000)

        packet_header = self.packet.generateIPHeader(self.source_host_ip, target)+self.packet.generateTCPHeader(source_port, dest_port, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0)
        packet_header_hex = (codecs.encode(packet_header, 'hex').decode())
        port_num = packet_header_hex[44:48]
        sock = socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP)
        sock.setsockopt(socket.IPPROTO_IP,socket.IP_HDRINCL, 1)
        response = self.packet.send_tcp_packet(packet_header, target, port_num, sock)
        sock.close()

        if response:
            hex_response = codecs.encode(response, 'hex').decode()
            if hex_response[65:68] == '012':
                service = self.get_port_service(dest_port)
                
                tempDict = dict(port=dest_port, status='open', service=service)
            
            elif hex_response[65:68] == '014' or hex_response[65:68] == '004':

                tempDict = dict(port=dest_port, status='closed', service='none')

        else:

            res_dict = self.syn_scan_thread_filtered_ports_retransmission(target, dest_port)
            if res_dict:
                if res_dict['status'] == 'open':
                    tempDict = res_dict
                elif res_dict['status'] == 'closed':
                    tempDict = res_dict
  
            else:
                tempDict = dict(port=dest_port, status='filtered', service='none')
        if tempDict is None:
            print("sd")
        return tempDict

    def syn_scan(self, target, ports):

        self.sub_module = 'Syn Scan'
        event_type = 'syn_scan_started'
        self.info_gather.send_module_time_to_server(self.module, self.sub_module, event_type)

        num_of_thread = multiprocessing.cpu_count() * 10

        self.ports_status.clear()

        p_list = []
        with ThreadPoolExecutor(num_of_thread) as executor:
            threads = []
            for port in ports:
                threads.append(executor.submit(self.syn_scan_thread, target, port))
                # executor.submit(self.syn_scan_thread, target, port)
            for thread in concurrent.futures.as_completed(threads):
                res = thread.result()
                if res: 
                    p_list.append(res)

        self.sub_module = 'Syn Scan'
        event_type = 'syn_scan_finished'
        self.info_gather.send_module_time_to_server(self.module, self.sub_module, event_type)
        
        return p_list

    #---------------------------------------------------------------------------------------------------------#
    #                                              NULL Scan                                                  #
    #---------------------------------------------------------------------------------------------------------#
    def null_scan(self, target, ports):
        
        with ThreadPoolExecutor() as executor:
            for port in ports:
                executor.submit(self.null_scan_thread, target, port)

    def null_scan_thread(self, target, dest_port):

        source_port = random.randint(9999, 50000)
        # source_port = 12345

        # ns=0x0,cwr=0x0,ece=0x0,urg=0x0,ack=0x0,psh=0x0,rst=0x0,syn=0x0,fin=0x0
        packet_header = self.packet.generateIPHeader(self.source_host_ip, target)+self.packet.generateTCPHeader(source_port, dest_port, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
        packet_header_hex = (codecs.encode(packet_header, 'hex').decode())
        port_num = packet_header_hex[44:48]
        sock = socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP)
        sock.setsockopt(socket.IPPROTO_IP,socket.IP_HDRINCL,1)
        response = self.packet.send_tcp_packet(packet_header, target, port_num, sock)
        sock.close()

        # if response:
        #     hex_response = codecs.encode(response, 'hex').decode()
        #     if hex_response[65:68] == '012':
        #         print(dest_port)
        #         service = self.get_port_service(dest_port)
        #         # print(service)
        #         self.add_open_ports_to_results(target, dest_port, service)
    #---------------------------------------------------------------------------------------------------------#
    #                                              FIN Scan                                                   #
    #---------------------------------------------------------------------------------------------------------#
    def fin_scan(self, target, ports):
        
        with ThreadPoolExecutor() as executor:
            for port in ports:
                executor.submit(self.fin_scan_thread, target, port)

    def fin_scan_thread(self, target, dest_port):

        source_port = random.randint(9999, 50000)
        # source_port = 12345

        # ns=0x0,cwr=0x0,ece=0x0,urg=0x0,ack=0x0,psh=0x0,rst=0x0,syn=0x0,fin=0x0
        packet_header = self.packet.generateIPHeader(self.source_host_ip, target)+self.packet.generateTCPHeader(source_port, dest_port, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1)
        packet_header_hex = (codecs.encode(packet_header, 'hex').decode())
        port_num = packet_header_hex[44:48]
        sock = socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP)
        sock.setsockopt(socket.IPPROTO_IP,socket.IP_HDRINCL,1)
        response = self.packet.send_tcp_packet(packet_header, target, port_num, sock)
        sock.close()

        # if response:
        #     hex_response = codecs.encode(response, 'hex').decode()
        #     if hex_response[65:68] == '012':
        #         print(dest_port)
        #         service = self.get_port_service(dest_port)
        #         # print(service)
        #         self.add_open_ports_to_results(target, dest_port, service)
    #---------------------------------------------------------------------------------------------------------#
    #                                              XMAS Scan                                                  #
    #---------------------------------------------------------------------------------------------------------#
    def xmas_scan(self, target, ports):
        
        with ThreadPoolExecutor() as executor:
            for port in ports:
                executor.submit(self.xmas_scan_thread, target, port)
    
    def xmas_scan_thread(self, target, dest_port):

        # source_port = random.randint(9999, 65000)
        source_port = 12345

        # ns=0x0,cwr=0x0,ece=0x0,urg=0x0,ack=0x0,psh=0x0,rst=0x0,syn=0x0,fin=0x0
        packet_header = self.packet.generateIPHeader(self.source_host_ip, target)+self.packet.generateTCPHeader(source_port, dest_port, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1)
        packet_header_hex = (codecs.encode(packet_header, 'hex').decode())
        port_num = packet_header_hex[44:48]
        sock = socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP)
        sock.setsockopt(socket.IPPROTO_IP,socket.IP_HDRINCL,1)
        response = self.packet.send_tcp_packet(packet_header, target, port_num, sock)
        sock.close()

        # if response:
        #     hex_response = codecs.encode(response, 'hex').decode()
        #     if hex_response[65:68] == '012':
        #         print(dest_port)
        #         service = self.get_port_service(dest_port)
        #         # print(service)
        #         self.add_open_ports_to_results(target, dest_port, service)
    
    
    def identify_only_open_and_filtered_ports(self, target, ports):
        
        only_open_ports_list = []
        only_filtered_ports_list = []
        closed_ports_list = []
        for port in ports:
            if port['status'] == 'open':
                only_open_ports_list.append(port)
            elif port['status'] == 'filtered':
                only_filtered_ports_list.append(port)
            elif port['status'] == 'closed':
                closed_ports_list.append(port)

        open_filtered_ports_dict = dict(target=target, ports=only_open_ports_list, filtered_ports_count=len(only_filtered_ports_list), 
                                        closed_ports_count=len(closed_ports_list))
        
        return open_filtered_ports_dict

    def port_scanning(self, target, ports):


        self.sub_module = ''
        event_type = 'port_scanning_started'
        self.info_gather.send_module_time_to_server(self.module, self.sub_module, event_type, None, None, target)

        self.source_host_ip = utilities.getHostIP(self.info_gather.interface)

        ports_status =  self.syn_scan(target, ports)

        ports_status_dict = dict(target=target, ports=ports_status)

        open_filtered_ports_dict = self.identify_only_open_and_filtered_ports(target, ports_status_dict['ports'])

        self.info_gather.add_ports_status_to_results(open_filtered_ports_dict)


        self.sub_module = ''
        event_type = 'port_scanning_finished'
        self.info_gather.send_module_time_to_server(self.module, self.sub_module, event_type, ports_status_dict, open_filtered_ports_dict, target)


    # self.module = 'Information Gathering'
    # self.sub_module = ''
    # event_type = 'information_gathering_finished'
    # self.info_gather.send_module_time_to_server(self.module, self.sub_module, event_type)


# if __name__=='__main__':

#     ports = []
#     for i in range(1,50000):
#         ports.append(i)

#     targets = ['192.168.18.14']

#     scan = PortScan()
#     scan.port_scanning(targets, ports)
