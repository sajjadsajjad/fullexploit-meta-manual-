import binascii
import socket
from netaddr import IPAddress, IPNetwork
import netifaces
import target_validation
import ipaddress

def getHostIP(interface):
    # """Get IP address of the source host

    # Returns
    # -------
    # string
    #     source host ip address
    # """

    if interface != '':
        host_ip = netifaces.ifaddresses(interface)
        host_ip = host_ip[netifaces.AF_INET][0]['addr']
    else:
        s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        s.connect(("8.8.8.8",80))
        host_ip = s.getsockname()[0]

    return host_ip

def send_data_to_server_in_chunks():
    pass

def parse_ip_header(header):
    
    i = 0
    version = header[i:i+1]

    i += 1
    ihl = header[i: i+1]

    i += 1
    d_services_field = header[i: i+2]

    i += 2
    total_length = header[i: i+4]

    i += 4
    identification = header[i: i+4]

    i += 4
    flags = header[i: i+4]

    i += 4
    ttl = header[i: i+2]

    i += 2
    protocol = header[i: i+2]

    i += 2
    checksum = header[i: i+4]

    i += 4
    source_ip = header[i: i+8]

    i += 8
    dest_ip = header[i: i+8]


    return source_ip, protocol

def parse_icmp_response(response):

    response_hex = binascii.hexlify(response)
    
    i = 0
    version = response_hex[i:i+1]

    i += 1
    ihl = int(response_hex[i: i+1]) * 4 * 2

    
    source_ip, protocol = parse_ip_header(response_hex[0:ihl])

    ip_addr = source_ip.decode()
    ip_addr = str(int(ip_addr[0:2], 16)) + '.' + str(int(ip_addr[2:4], 16)) + '.' + str(int(ip_addr[4:6], 16)) + '.' + str(int(ip_addr[6:8], 16))
    
    return ip_addr, protocol

def parse_tcp_response(response):
    
    response_hex = binascii.hexlify(response)
    
    i = 0
    version = response_hex[i:i+1]

    i += 1
    ihl = int(response_hex[i: i+1]) * 4 * 2

    
    source_ip, protocol = parse_ip_header(response_hex[0:ihl])

    ip_addr = source_ip.decode()
    ip_addr = str(int(ip_addr[0:2], 16)) + '.' + str(int(ip_addr[2:4], 16)) + '.' + str(int(ip_addr[4:6], 16)) + '.' + str(int(ip_addr[6:8], 16))
    
    return ip_addr, protocol

# def get_default_interface(available_interfaces, selected_interface):
    
#     default_interface = ''
#     host_ip = target_validation.getHostIP(selected_interface)
#     for interface in available_interfaces:
#         addr = netifaces.ifaddresses(interface)
#         try:
#             addr = addr[netifaces.AF_INET][0]['addr']
#         except:
#             addr = ''

#         if addr == host_ip:
#             default_interface = interface
#             break

#     return default_interface


def get_available_interfaces():
    # selected_interface = ''
    available_interfaces = netifaces.interfaces()
    default_interface = get_default_interface()
    default_network_inputs = get_ifaces_subnet(available_interfaces, default_interface)
    
    for default_networks in default_network_inputs:
        if default_networks['default'] == 'True':
            default_interface = default_networks
    return available_interfaces, default_interface, default_network_inputs

def get_default_interface():
    
    interface = ''
    host_ip = getHostIP(interface)
    net_ifaces = netifaces.interfaces()
    current_iface = ''
    for iface in net_ifaces:
        try:
            iface_ip = netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr']
            if host_ip == iface_ip:
                current_iface = iface
        except:
            pass
    
    return current_iface

def get_ifaces_subnet(available_interfaces, default_interface):

    interfaces_default_network_list = []
    for interface in available_interfaces:
        default_input = ''
        try:
            subnet = netifaces.ifaddresses(interface)[netifaces.AF_INET][0]

            cidr = subnet['netmask']
            cidr = IPAddress(cidr).netmask_bits()

            network_ip = IPNetwork(subnet['addr'] + '/' + str(cidr)).network
            network_ip = str(network_ip)

            default_input = network_ip + '/' + str(cidr)

        except Exception as e:
            pass
        
        if interface == default_interface:
            default = 'True'
        else:
            default = 'False'
        tempDict = dict(interface=interface, default_input=default_input, default=default)
        interfaces_default_network_list.append(tempDict)
    return interfaces_default_network_list


def is_float(num):
    try:
        float(num)
        return True
    except ValueError:
        return False

def detect_public_vs_private_ip(input_type, target_input):
    
    ip_type = ''
    if input_type == 'single_ip':
        if ipaddress.ip_address(target_input).is_private:
            return 'private'
        else:
            return 'public'

    elif input_type == 'ip_range':
        if ipaddress.ip_address(target_input.split('-')[0]).is_private:
            return 'private'
        else:
            return 'public'

    elif input_type == 'cidr':
        if ipaddress.ip_address(target_input.split('/')[0]).is_private:
            return 'private'
        else:
            return 'public'

    elif input_type == 'domain_name':
        return 'public'