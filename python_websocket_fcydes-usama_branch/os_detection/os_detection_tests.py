from statistics import stdev, mean
import math
import zlib
import binascii

def calculate_gcd(x, y):
    while(y):
        x, y = y, x % y
  
    return x

def gcd_test(responses_list):
    
    diff1 = []
    seq_num_max = pow(2,32)   # Sequence number is 32-bit
    for i in range (0, len(responses_list) - 1):
        
        # diff_val = abs(responses_list[i + 1]['TCP'].seq - responses_list[i]['TCP'].seq)
        # diff1.append(diff_val)
        # responses_list[i].show()
        # print(str(responses_list[i]['TCP'].seq) + ' : '+ str(responses_list[i+1]['TCP'].seq))
        # print(responses_list[i + 1]['TCP'].seq - responses_list[i]['TCP'].seq)
        # print(responses_list[i]['TCP'].seq)
        if responses_list[i+1]['TCP'].seq > responses_list[i]['TCP'].seq:
            diff = abs(responses_list[i + 1]['TCP'].seq - responses_list[i]['TCP'].seq)
            diff1.append(diff)
        else:
            diff_x = abs((seq_num_max - responses_list[i]['TCP'].seq) + responses_list[i+1]['TCP'].seq)
            diff_y = abs(responses_list[i + 1]['TCP'].seq - responses_list[i]['TCP'].seq)
            
            if diff_x < diff_y:
                diff = diff_x
            else:
                diff = diff_y

            diff1.append(diff)

    
    gcd = calculate_gcd(diff1[0], diff1[1])
    for i in range(2, len(diff1)):
        gcd = calculate_gcd(gcd, diff1[i])

    # gcd = str(hex(gcd))[2:].upper()
    return gcd, diff1


def isr_test(diff1, time_stamps_diff):
    
    seq_rates = []
    for i in range(0, len(diff1)):
        seq_rates.append(diff1[i]/((time_stamps_diff[i]/2)/1000000))
    
    avg = round(mean(seq_rates))
    
    if avg < 1:
        isr = 0
    else:
        isr = round(math.log2(avg) * 8)

    isr = str(hex(isr))[2:].upper()
    return isr, seq_rates

def sp_test(responses_list, seq_rates, gcd):
    
    diff2 = []
    div_gcd = 1
    if len(responses_list) >= 4:

        if gcd > 9:
            div_gcd = gcd

        for i in range(0, len(seq_rates)):
            diff2.append(seq_rates[i] / div_gcd)

        sd = stdev(diff2)
        if sd <= 1:
            sp = 0

        else:
            sp = round(math.log2(sd) * 8)
            
    
    sp = str(hex(sp))[2:].upper()
    return sp

def ti_ci_ii_test(r_list, flag):
    
    responses_list = []
    for response in r_list:
        if response:
            responses_list.append(response)

    if flag == 'TI':
        required_responses = 3
    elif flag == 'CI':
        required_responses = 2
    elif flag == 'II':
        required_responses = 2

    if len(responses_list) >= required_responses:
        ip_id_max = pow(2,16)   # IP ID is 16-bit
        p_ip_id_list = []
        for response in responses_list:
            p_ip_id_list.append(response['IP'].id)

        condition_1 = False
        condition_2 = False
        condition_3 = False
        condition_4 = False
        condition_5 = False
        condition_6 = False
        
        # if all ip ids are equal to 0
        condition_1 = True
        all_ip_ids_zero = True
        for ip_id in p_ip_id_list:
            if ip_id != 0:
                all_ip_ids_zero = False
                condition_1 = False
                break
        if all_ip_ids_zero:
            t_c_i = 'Z'

        # if all ip ids are same
        if not condition_1:
            condition_3 = True
            all_ip_ids_equal = True
            for ip_id in p_ip_id_list:
                if p_ip_id_list[0] != ip_id:
                    all_ip_ids_equal = False
                    condition_3 = False
                    break
            if all_ip_ids_equal:
                t_c_i = str(hex(p_ip_id_list[0]))[2:]

        # condition 2        
        if not condition_1 and not condition_3:
            condition_2 = True
            for i in range(0, len(p_ip_id_list) - 1):
                if (p_ip_id_list[i] < p_ip_id_list[i+1]):
                    diff = p_ip_id_list[i+1] - p_ip_id_list[i]
                else:
                    diff = (ip_id_max - p_ip_id_list[i]) + p_ip_id_list[i+1]
                
                if (diff >= 20000):
                    t_c_i = 'RD'
                    break
                else:
                    condition_2 = False
            

        # condition 4
        if not condition_1 and not condition_2 and not condition_3:
            condition_4 = True
            for i in range(0, len(p_ip_id_list) - 1):
                if (p_ip_id_list[i] < p_ip_id_list[i+1]):
                    diff = p_ip_id_list[i+1] - p_ip_id_list[i]
                else:
                    diff = (ip_id_max - p_ip_id_list[i]) + p_ip_id_list[i]
                
                
                if (diff > 1000 and diff%256 != 0):
                    t_c_i = 'RI'
                    break
                elif (diff >= 256000 and diff%256 == 0):
                    t_c_i = 'RI'
                    break
                else:
                    condition_4 = False

        # condition 5
        if not condition_1 and not condition_2 \
            and not condition_3 and not condition_4:

            condition_5 = True
            all_div_by_256 = True
            for i in range(0, len(p_ip_id_list) - 1):
                diff = p_ip_id_list[i+1] - p_ip_id_list[i] > 1000
                if not diff%256 and diff <=5120:
                    all_div_by_256 = False
                    condition_5 = False
                    break
            if all_div_by_256:
                t_c_i = 'BI'

        # condition 6
        if not condition_1 and not condition_2 and \
            not condition_3 and not condition_4 and \
                not condition_5:

            condition_6 = True
            diff_lt_10 = True
            for i in range(0, len(p_ip_id_list) - 1):
                diff = p_ip_id_list[i+1] - p_ip_id_list[i]
                if not diff < 10:
                    diff_lt_10 = False
                    condition_6 = False
                    break
            if diff_lt_10:
                t_c_i = 'I'

        if not condition_1 and not condition_2 and \
            not condition_3 and not condition_4 and \
                not condition_5 and not condition_6:
            t_c_i = 'Ommit'
    
        return t_c_i

    else:
        return 'Ommit'


def ss_test(responses_list, ie_res_list):
    
    first_p1_p6_ip_id = responses_list[0]['IP'].id 
    last_p1_p6_ip_id = responses_list[len(responses_list) - 1]['IP'].id
    num_of_p1_p6_res = len(responses_list)
    avg = (last_p1_p6_ip_id - first_p1_p6_ip_id) / (num_of_p1_p6_res - 1)

    first_ie_ip_id = ie_res_list[0]['IP'].id 
    
    if (first_ie_ip_id < (last_p1_p6_ip_id + 3 * avg)):
        return 'S'
    else:
        return 'O'

def ts_test(responses_list, time_stamp_diffs):
    
    timestamp_list = []
    t_stamp_diff = []
    t_stamp_rate = []
    time_stamp_max = pow(2,32)

    condition_1 = False
    for response in responses_list:
        ops = response['TCP'].options
        timestamp_exists = False
        timestamp_zero = False
        for o in ops:
            if o[0] == 'Timestamp':
                if o[1][0] == 0:
                    timestamp_zero = True
                    break
                timestamp_list.append(o[1][0])
                timestamp_exists = True
        if timestamp_zero:
            ts = '0'
            condition_1 = True
            break        
        if not timestamp_exists:
            ts = 'U'
            condition_1 = True
            break
    
    if not condition_1:
        condition_2 = False
        for i in range (0, len(timestamp_list) - 1):
            if timestamp_list[i+1] > timestamp_list[i]:
                t_stamp_diff.append(timestamp_list[i + 1] - timestamp_list[i])
            else:
                t_stamp_diff.append((time_stamp_max - timestamp_list[i]) + timestamp_list[i+1])
        
        for i in range (0, len(t_stamp_diff)):
            t_stamp_rate.append(t_stamp_diff[i] / (time_stamp_diffs[i]/1000000))
            # t_stamp_rate.append(t_stamp_diff[i] / (0.1))

        t_stamp_avg_increment = mean(t_stamp_rate)

        if t_stamp_avg_increment >= 0 and t_stamp_avg_increment <= 5.66:
            ts = '1'           
            condition_2 = True
        elif t_stamp_avg_increment >= 70 and t_stamp_avg_increment <= 150:
            ts = '7'
            condition_2 = True
        elif t_stamp_avg_increment >= 150 and t_stamp_avg_increment <= 350:
            ts = '8'
            condition_2 = True
    
    if not condition_1 and not condition_2:
        ts = round(math.log2(t_stamp_avg_increment))
        ts = str(hex(ts))[2:].upper()

    
    return ts

def o_test(p_res):

    ops = ''
    for option in p_res['TCP'].options:
        if option[0] == 'EOL':
            ops += 'E'
        elif option[0] == 'NOP':
            ops += 'N'
        elif option[0] == 'MSS':
            ops += 'M' + str(hex(option[1])[2:]).upper()
        elif option[0] == 'WScale':
            ops += 'W' + str(hex(option[1])[2:]).upper()
        elif option[0] == 'Timestamp':
            ops += 'T'
            tsval = option[1][0]
            tsecr = option[1][1]

            if tsval == 0:
                ops += '0'
            else:
                ops += '1'

            if tsecr == 0:
                ops += '0'
            else:
                ops += '1'

        elif option[0] == 'SAckOK':
            ops += 'S'
    
    return ops

def w_test(p_res):

    win = str(hex(p_res['TCP'].window))[2:].upper()

    return win

def r_test(p_res):
    
    if p_res:
        return 'Y'
    else:
        return 'N'

def df_test(p_res):
    
    if 'DF' in p_res['IP'].flags:
        df = 'Y'
    else:
        df = 'N'

    return df

def dfi_test(p1, p1_res, p2, p2_res):
    
    if not 'DF' in p1_res['IP'].flags and not 'DF' in p2_res['IP'].flags:
        df = 'N'
    elif not 'DF' in p1_res['IP'].flags and not 'DF' in p2_res['IP'].flags:
        df = 'Y'
    elif 'DF' in p1_res['IP'].flags and 'DF' in p1['IP'].flags and 'DF' in p2_res['IP'].flags and 'DF' in p2['IP'].flags:
        df = 'S'
    else:
        df = 'O'

    return df


def t_test(p, p_res, u1=None, u1_res=None):

    # p.show()
    # p_res.show()
    
    t = None
    if u1_res is None:
        if 'ICMP' in p_res:
            try:
                hop_distance = p['IP'].ttl - p_res['ICMP'].ttl
                t = p_res['IP'].ttl + hop_distance
            except:
                pass
    else:
        if 'ICMP' in u1_res:
            hop_distance = u1['IP'].ttl - u1_res['ICMP'].ttl
            t = p_res['IP'].ttl + hop_distance

    if t:
        t = str(hex(t))[2:].upper()
    return t

def tg_test(p_res):
    
    if p_res['IP'].ttl <= 32:
        tg = 32
    elif p_res['IP'].ttl <= 64:
        tg = 64
    elif p_res['IP'].ttl <= 128:
        tg = 128
    elif p_res['IP'].ttl <= 255:
        tg = 255
    
    tg = str(hex(tg))[2:].upper()
    
    return tg

def cc_test(p_res):

    if 'E' in p_res['TCP'].flags:
        cc = 'Y'
    elif not 'E' in p_res['TCP'].flags and not 'C' in p_res['TCP'].flags:
        cc = 'N'
    elif 'E' in p_res['TCP'].flags and 'C' in p_res['TCP'].flags:
        cc = 'S'
    else:
        cc = 'O'

    return cc

def q_test(p_res):

    if p_res['TCP'].reserved != 0:
        q = 'R'
    if p_res['TCP'].urgptr != 0:
        q = 'U'
    else:
        q = ''
    
    return q

def s_test(p, p_res):

    probe_ack = p['TCP'].ack
    res_seq = p_res['TCP'].seq
    if res_seq == 0:
        s = 'Z'
    elif res_seq == probe_ack:
        s = 'A'
    elif res_seq == probe_ack + 1:
        s = 'A+'
    else:
        s = 'O'

    return s

def a_test(p, p_res):

    probe_seq = p['TCP'].seq
    if p_res['TCP'].ack == 0:
        a = 'Z'
    elif p_res['TCP'].ack == probe_seq:
        a = 'S'
    elif p_res['TCP'].ack == probe_seq + 1:
        a = 'S+'
    else:
        a = 'O'

    return a

def f_test(p_res):

    f = str(p_res['TCP'].flags)[::-1]

    return f

def rd_test(p_res):
    # p_res.show()
    if 'RAW' in p_res:
        p_load = p_res.load.decode()
        if p_load != '':
            rd = zlib.crc32(p_load)

        else:
            rd = 0
    else:
        rd = 0
    
    rd = str(hex(rd))[2:].upper()
    
    return rd

def ipl_test(p_res):
    
    ipl = len(p_res)
    
    ipl = str(hex(ipl))[2:].upper()

    return ipl

def un_test(p_res):
    
    # icmp_resp = (p_res['ICMP'])
    # print(icmp_resp)
    # print(icmp_resp[0])
    # print(icmp_resp[4:8])
    # un = int.from_bytes(icmp_resp[4:8], byteorder='big')
    # print(un)
    # p_res.show()
    
    icmp_resp = binascii.hexlify(bytes(p_res['ICMP']))
    un = int(icmp_resp[8:16].decode())
    un = str(hex(un))[2:].upper()
    
    return un


def ripl_test(p_res):
    
    ripl = p_res['ICMP'].len
    if ripl == 328:
        ripl = 'G'
    else:
        ripl = str(hex(ripl))[2:].upper()

    return ripl

def rid_test(p_res):
    
    rid = p_res['IP in ICMP'].id

    if rid == 4162:
        rid = 'G'
    else:
        rid = str(hex(rid))[2:].upper()

    return rid

def ripck_test(p, p_res):
    
    # p.show2()
    # p_res.show2()
    # # p = IP(p.build())
    # del p['IP'].chksum

    if (p['IP'].chksum == p_res['IP in ICMP'].chksum):
        ripck = 'G'
    elif (p_res['IP in ICMP'].chksum == 0):
        ripck = 'Z'
    else:
        ripck = 'I'

    return ripck


def ruck_test(p, p_res):
    
    if (p['UDP'].chksum == p_res['UDP in ICMP'].chksum):
        ruck = 'G'
    
    else:
        ruck = p_res['UDP in ICMP'].chksum
        ruck = str(hex(ruck))[2:].upper()

    return ruck

def rud_test(p, p_res):

    len = p_res['IP'].len
    res_payload = bytes(p_res)[len:]
    probe_payload = bytes(p.load)

    if probe_payload == res_payload or res_payload == b'':
        rud = 'G'
    else:
        rud = 'I'
    # if p.load
    # if p_res.load:
    #     if (p_res.load == p.load or p_res.load.decode() == ''):
    #         rud = 'G'
        
    #     else: rud = 'I'
    # else:
    #     print("No Payload returned")
    #     rud = ''

    return rud

    

def cd_test(p1, p1_res, p2, p2_res):
    
    if(p1_res['ICMP'].code==0 and p2_res['ICMP'].code==0):
        cd = 'Z'
    
    elif(p1['ICMP'].code==p1_res['ICMP'].code and p2['ICMP'].code==p2_res['ICMP'].code):
        cd = 'S'
    
    elif(p1_res['ICMP'].code==p2_res['ICMP'].code and p1_res['ICMP'].code != 0):
        cd = p1_res['ICMP'].code
        cd = str(hex(cd))[2:].upper()
    else:
        cd = 'O'

    return cd
    

