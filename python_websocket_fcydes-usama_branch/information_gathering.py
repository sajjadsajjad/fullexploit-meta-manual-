from heapq import merge
from operator import mod
import threading
import json
from datetime import datetime
import sqlite3
import os
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor

import target_validation
import host_discovery
import port_scan

from hostname_enumeration import host_name_enumeration
from os_detection import os_detection
from service_version_enumeration import service_version_detection
from vulnerability_analysis import vulnerabilities_detection
from dhcp_fingerprinting import dhcp_fingerprinting


import utilities

import sys
def get_size(obj, seen=None):
    """Recursively finds size of objects"""
    size = sys.getsizeof(obj)
    if seen is None:
        seen = set()
    obj_id = id(obj)
    if obj_id in seen:
        return 0
    # Important mark as seen *before* entering recursion to gracefully handle
    # self-referential objects
    seen.add(obj_id)
    if isinstance(obj, dict):
        size += sum([get_size(v, seen) for v in obj.values()])
        size += sum([get_size(k, seen) for k in obj.keys()])
    elif hasattr(obj, '__dict__'):
        size += get_size(obj.__dict__, seen)
    elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes, bytearray)):
        size += sum([get_size(i, seen) for i in obj])
    return size

class InformationGathering:

    def __init__(self, user_id, web_socket):

        self.user_id = user_id
        self.web_socket = web_socket
        
        self.interface = ''
        self.host_discovery_setting = ''
        self.port_scanning_setting = ''
        self.scan_type = ''

        self.h_discovery = host_discovery.HostDiscovery(self, self.user_id, self.web_socket)

        self.p_scan = port_scan.PortScan(self, user_id, web_socket)

        self.info_gather_results = []

        self.module = 'Information Gathering'

        self.module_start_time = None

        self.module_completion_time = None

        self.module_elapsed_time = None

        self.information_gathering_status = None

        self.vulnerability_scanning_status = None

        self.open_ports_list_for_version_detection = []

        self.input_type = None

        self.ip_type = None

        self.top_tcp_ports = [
        1,3,4,6,7,9,13,17,19,20,21,22,23,24,25,26,30,32,33,37,42,43,49,53,70,
        79,80,81,82,83,84,85,88,89,90,99,100,106,109,110,111,113,119,125,135,
        139,143,144,146,161,163,179,199,211,212,222,254,255,256,259,264,280,
        301,306,311,340,366,389,406,407,416,417,425,427,443,444,445,458,464,
        465,481,497,500,512,513,514,515,524,541,543,544,545,548,554,555,563,
        587,593,616,617,625,631,636,646,648,666,667,668,683,687,691,700,705,
        711,714,720,722,726,749,765,777,783,787,800,801,808,843,873,880,888,
        898,900,901,902,903,911,912,981,987,990,992,993,995,999,1000,1001,
        1002,1007,1009,1010,1011,1021,1022,1023,1024,1025,1026,1027,1028,
        1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,
        1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,
        1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,
        1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,
        1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,
        1094,1095,1096,1097,1098,1099,1100,1102,1104,1105,1106,1107,1108,
        1110,1111,1112,1113,1114,1117,1119,1121,1122,1123,1124,1126,1130,
        1131,1132,1137,1138,1141,1145,1147,1148,1149,1151,1152,1154,1163,
        1164,1165,1166,1169,1174,1175,1183,1185,1186,1187,1192,1198,1199,
        1201,1213,1216,1217,1218,1233,1234,1236,1244,1247,1248,1259,1271,
        1272,1277,1287,1296,1300,1301,1309,1310,1311,1322,1328,1334,1352,
        1417,1433,1434,1443,1455,1461,1494,1500,1501,1503,1521,1524,1533,
        1556,1580,1583,1594,1600,1641,1658,1666,1687,1688,1700,1717,1718,
        1719,1720,1721,1723,1755,1761,1782,1783,1801,1805,1812,1839,1840,
        1862,1863,1864,1875,1900,1914,1935,1947,1971,1972,1974,1984,1998,
        1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2013,
        2020,2021,2022,2030,2033,2034,2035,2038,2040,2041,2042,2043,2045,
        2046,2047,2048,2049,2065,2068,2099,2100,2103,2105,2106,2107,2111,
        2119,2121,2126,2135,2144,2160,2161,2170,2179,2190,2191,2196,2200,
        2222,2251,2260,2288,2301,2323,2366,2381,2382,2383,2393,2394,2399,
        2401,2492,2500,2522,2525,2557,2601,2602,2604,2605,2607,2608,2638,
        2701,2702,2710,2717,2718,2725,2800,2809,2811,2869,2875,2909,2910,
        2920,2967,2968,2998,3000,3001,3003,3005,3006,3007,3011,3013,3017,
        3030,3031,3052,3071,3077,3128,3168,3211,3221,3260,3261,3268,3269,
        3283,3300,3301,3306,3322,3323,3324,3325,3333,3351,3367,3369,3370,
        3371,3372,3389,3390,3404,3476,3493,3517,3527,3546,3551,3580,3659,
        3689,3690,3703,3737,3766,3784,3800,3801,3809,3814,3826,3827,3828,
        3851,3869,3871,3878,3880,3889,3905,3914,3918,3920,3945,3971,3986,
        3995,3998,4000,4001,4002,4003,4004,4005,4006,4045,4111,4125,4126,
        4129,4224,4242,4279,4321,4343,4443,4444,4445,4446,4449,4550,4567,
        4662,4848,4899,4900,4998,5000,5001,5002,5003,5004,5009,5030,5033,
        5050,5051,5054,5060,5061,5080,5087,5100,5101,5102,5120,5190,5200,
        5214,5221,5222,5225,5226,5269,5280,5298,5357,5405,5414,5431,5432,
        5440,5500,5510,5544,5550,5555,5560,5566,5631,5633,5666,5678,5679,
        5718,5730,5800,5801,5802,5810,5811,5815,5822,5825,5850,5859,5862,
        5877,5900,5901,5902,5903,5904,5906,5907,5910,5911,5915,5922,5925,
        5950,5952,5959,5960,5961,5962,5963,5987,5988,5989,5998,5999,6000,
        6001,6002,6003,6004,6005,6006,6007,6009,6025,6059,6100,6101,6106,
        6112,6123,6129,6156,6346,6389,6502,6510,6543,6547,6565,6566,6567,
        6580,6646,6666,6667,6668,6669,6689,6692,6699,6779,6788,6789,6792,
        6839,6881,6901,6969,7000,7001,7002,7004,7007,7019,7025,7070,7100,
        7103,7106,7200,7201,7402,7435,7443,7496,7512,7625,7627,7676,7741,
        7777,7778,7800,7911,7920,7921,7937,7938,7999,8000,8001,8002,8007,
        8008,8009,8010,8011,8021,8022,8031,8042,8045,8080,8081,8082,8083,
        8084,8085,8086,8087,8088,8089,8090,8093,8099,8100,8180,8181,8192,
        8193,8194,8200,8222,8254,8290,8291,8292,8300,8333,8383,8400,8402,
        8443,8500,8600,8649,8651,8652,8654,8701,8800,8873,8888,8899,8994,
        9000,9001,9002,9003,9009,9010,9011,9040,9050,9071,9080,9081,9090,
        9091,9099,9100,9101,9102,9103,9110,9111,9200,9207,9220,9290,9415,
        9418,9485,9500,9502,9503,9535,9575,9593,9594,9595,9618,9666,9876,
        9877,9878,9898,9900,9917,9929,9943,9944,9968,9998,9999,10000,10001,
        10002,10003,10004,10009,10010,10012,10024,10025,10082,10180,10215,
        10243,10566,10616,10617,10621,10626,10628,10629,10778,11110,11111,
        11967,12000,12174,12265,12345,13456,13722,13782,13783,14000,14238,
        14441,14442,15000,15002,15003,15004,15660,15742,16000,16001,16012,
        16016,16018,16080,16113,16992,16993,17877,17988,18040,18101,18988,
        19101,19283,19315,19350,19780,19801,19842,20000,20005,20031,20221,
        20222,20828,21571,22939,23502,24444,24800,25734,25735,26214,27000,
        27352,27353,27355,27356,27715,28201,30000,30718,30951,31038,31337,
        32768,32769,32770,32771,32772,32773,32774,32775,32776,32777,32778,
        32779,32780,32781,32782,32783,32784,32785,33354,33899,34571,34572,
        34573,35500,38292,40193,40911,41511,42510,44176,44442,44443,44501,
        45100,48080,49152,49153,49154,49155,49156,49157,49158,49159,49160,
        49161,49163,49165,49167,49175,49176,49400,49999,50000,50001,50002,
        50003,50006,50300,50389,50500,50636,50800,51103,51493,52673,52822,
        52848,52869,54045,54328,55055,55056,55555,55600,56737,56738,57294,
        57797,58080,60020,60443,61532,61900,62078,63331,64623,64680,65000,
        65129,65389]
        # self.top_tcp_ports = [23, 80]

    def send_module_start_finish_time_to_server(self, event_type, module, sub_module):
        
        print('[*] Event: ' + event_type)

        self.module_elapsed_time = None

        module_time = datetime.now()
        module_time_str_format = module_time.strftime('%Y-%m-%d %H:%M:%S')
        
        if event_type == 'information_gathering_started':
            self.module_start_time = module_time

        elif event_type == 'information_gathering_finished':
            self.module_completion_time = module_time
            self.module_elapsed_time = (self.module_completion_time - self.module_start_time).seconds

        
        elif event_type == 'vulnerability_scanning_started':
            self.module_start_time = module_time
        
        elif event_type == 'vulnerability_scanning_finished':
            self.module_completion_time = module_time
            self.module_elapsed_time = (self.module_completion_time - self.module_start_time).seconds
        

        elif event_type == 'exploitation_started':
            self.module_start_time = module_time
        
        elif event_type == 'exploitation_finished':
            self.module_completion_time = module_time
            self.module_elapsed_time = (self.module_completion_time - self.module_start_time).seconds


        if self.module_elapsed_time:
            hours, remainder = divmod(self.module_elapsed_time, 3600)
            minutes, seconds = divmod(remainder, 60)
            self.module_elapsed_time = '{:02}:{:02}:{:02}'.format(int(hours), int(minutes), int(seconds))
            module_info_dict = dict(module=module, sub_module=sub_module, time=module_time_str_format, elapsed_time=self.module_elapsed_time)
        else:
            module_info_dict = dict(module=module, sub_module=sub_module, time=module_time_str_format)

        
        if self.module_completion_time:
            self.write_module_time_to_db(module, self.module_start_time, self.module_completion_time, self.module_elapsed_time)

        tempDict = dict(user_id=self.user_id, eventType=event_type, data=module_info_dict)
        self.web_socket.send(json.dumps(tempDict))


    def send_module_time_to_server(self, module, sub_module, event_type, ports_status=None, open_ports=None, target_ip=None):    

        if target_ip:
            print('[*] ' + event_type + ' ' + target_ip)
        else:
            print('[*] ' + event_type)

        module_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        module_info_dict = dict(module=module, sub_module=sub_module, time=module_time, target_ip=target_ip)
        tempDict = dict(user_id=self.user_id, eventType=event_type, data=module_info_dict)
        self.web_socket.send(json.dumps(tempDict))

        if event_type == 'host_discovery_finished':
            self.start_hostname_enumeration()
            self.start_port_scanning()

        elif event_type == 'port_scanning_finished':
            self.start_os_detection(ports_status)

            self.open_ports_list_for_version_detection.append(open_ports)


    def send_data_to_server(self, data, event_type):
        
        tempDict2 = dict(user_id=self.user_id, eventType=event_type, data=data)
        self.web_socket.send(json.dumps(tempDict2))

    def start_scanning(self, scan_data):
        print(scan_data)
        target_input = scan_data['ip']
        scan_settings = scan_data['scanSettings']

        self.write_scan_details_to_db(scan_data)

        self.sub_module = ''
        event_type = 'information_gathering_started'
        # self.send_module_time_to_server(self.module, self.sub_module, event_type, None, None, None)
        self.send_module_start_finish_time_to_server(event_type, self.module, self.sub_module)

        scan_mode = scan_settings['mode']
        if scan_mode == 'default':
            default_interface = utilities.get_default_interface()
            self.interface = default_interface
            self.host_discovery_setting = 'arp'
            self.port_scanning_setting = 'syn'
            self.scan_type = 'normal'   # TODO: remove hardcoded value

        elif scan_mode == 'custom':
            self.interface = scan_settings['interface']
            # self.host_discovery_setting = scan_settings['hostDiscovery']
            self.host_discovery_setting = 'hybrid'
            self.port_scanning_setting = scan_settings['portScanning']
            self.scan_type = 'normal'   # TODO: remove hardcoded value

        if self.scan_type == 'normal':
            self.start_host_discovery(target_input)

        elif self.scan_type == 'hard':
            dhcp_fingerprinting.main(self.interface)
            
        else:
            self.start_host_discovery(target_input)

    def start_host_discovery(self, target_input):

        host_ip = target_validation.getHostIP(self.interface)

        targets, input_type = target_validation.process_target_address(target_input, self.interface)

        self.input_type = input_type

        self.ip_type = utilities.detect_public_vs_private_ip(self.input_type, target_input)

        if host_ip in targets:
            targets.remove(host_ip)

        arp_ping_thread = threading.Thread(target=self.h_discovery.host_discovery, args=(targets,))
        arp_ping_thread.start()        

    def start_hostname_enumeration(self):
        targets = []
        for x in self.info_gather_results:
            targets.append(x['dest_host'])

        host_name_enumeration.enumerate_hostname(self, targets)

    def start_port_scanning(self):
        
        targets = []
        for x in self.info_gather_results:
            targets.append(x['dest_host'])

        with ThreadPoolExecutor(5) as executor:
            threads = []
            for target in targets:
                threads.append(executor.submit(self.p_scan.port_scanning, target, self.top_tcp_ports))

            for thread in concurrent.futures.as_completed(threads): # Wait for all the threads to finish
                thread.result() 
         
        with ThreadPoolExecutor(5) as executor:
            threads = []
            for open_ports in self.open_ports_list_for_version_detection:
                threads.append(executor.submit(self.start_version_detection, open_ports))

            for thread in concurrent.futures.as_completed(threads): # Wait for all the threads to finish
                thread.result()

        self.information_gathering_status = 'Finished'

        self.module = 'Information Gathering'
        self.sub_module = ''
        event_type = 'store_data_to_db'
        self.send_module_time_to_server(self.module, self.sub_module, event_type)

        self.write_info_gather_results_to_db()

        self.module = 'Information Gathering'
        self.sub_module = ''
        event_type = 'information_gathering_finished'
        # self.send_module_time_to_server(self.module, self.sub_module, event_type)
        self.send_module_start_finish_time_to_server(event_type, self.module, self.sub_module)

        # module_info_dict = dict(module=module, sub_module=sub_module, start_time=start_time, target_ip=target_ip)
        
        
    def start_os_detection(self, ports_dict):
        
        os_detection.os_detect_main(self, ports_dict)
        
    def start_version_detection(self, open_ports):
        # pass

        ports_version = service_version_detection.version_detection(self, open_ports)
        
        self.add_ports_versions_to_results(ports_version)
    
    
    def start_vulnerability_scanning(self):

        if self.information_gathering_status == 'Finished':
            
            self.sub_module = ''
            event_type = 'vulnerability_scanning_started'
            # self.send_module_time_to_server(self.module, self.sub_module, event_type, None, None, None)
            self.send_module_start_finish_time_to_server(event_type, self.module, self.sub_module)
            results_db_path = './results.db'
            if os.path.exists(results_db_path):
                conn = sqlite3.connect(results_db_path)

                cursor = conn.cursor()

                cursor.execute('''SELECT * from ports;''')

                ports_results = cursor.fetchall()

                conn.commit()

                conn.close()


            else:
                print("Results DB not found. Cannot continue Vulnerability Detection")
                
                exit()

            info_gather_dict = {}
            for port_res in ports_results:
                if not port_res[0] in info_gather_dict.keys():
                    info_gather_dict[port_res[0]] = []
                tempDict = dict(port=port_res[1], service=port_res[2], service_version_display=port_res[3], vendor_product_name=port_res[4], version=port_res[5], info=port_res[6], hostname=port_res[7], operating_system=port_res[8], device_type=port_res[9])
                info_gather_dict[port_res[0]].append(tempDict)

            for k, _ in info_gather_dict.items():

                ########### SAJJAD #############

                vulns, manual_vulns, summary = vulnerabilities_detection.vulnerabilities_detection(info_gather_dict[k])
 
                dataDict = dict(ip=k, vuln_summary=summary)

                ########### SAJJAD #############
                
                tempDict2 = dict(user_id=self.user_id, eventType='ip_vulnerabilities_summary', data=dataDict)
                self.web_socket.send(json.dumps(tempDict2))
                
                self.write_vulnerabilities_result_to_db(vulns,k)

                ########### SAJJAD #############

                self.write_vulnerabilities_manual_result_to_db(manual_vulns, k)
                ########### SAJJAD #############

    
            self.sub_module = ''
            event_type = 'vulnerability_scanning_finished'
            # self.send_module_time_to_server(self.module, self.sub_module, event_type, None, None, None)
            self.send_module_start_finish_time_to_server(event_type, self.module, self.sub_module)

            self.vulnerability_scanning_status = 'Finished'


    def add_active_hosts_to_results(self, active_hosts_dict):
        
        self.info_gather_results.append(active_hosts_dict)
        
    def add_host_names_to_result(self, active_hosts_dict):
        for x in self.info_gather_results:
            if x['dest_host'] == active_hosts_dict['dest_host']:
                x['host_name'] = active_hosts_dict['host_name']

    def add_ports_status_to_results(self, ports_status_dict):
        
        for x in self.info_gather_results:
            if not 'ports' in x.keys():
                x['ports'] = []

            if not 'filtered_ports_count' in x.keys():
                x['filtered_ports_count'] = 0
            
            if not 'closed_ports_count' in x.keys():
                x['closed_ports_count'] = 0

            if x['dest_host'] == ports_status_dict['target']:
                for port in ports_status_dict['ports']:
                    tempDict = dict(port=port['port'], service=port['service'])
                    x['ports'].append(tempDict)

                x['filtered_ports_count'] = ports_status_dict['filtered_ports_count']
                x['closed_ports_count'] = ports_status_dict['closed_ports_count']
                
    def add_os_info_to_results(self, os_info_dict):
        
        for x in self.info_gather_results:
            if not 'os' in x.keys():
                x['os'] = {}

            if x['dest_host'] == os_info_dict['target']:
                x['os'] = os_info_dict['os_info'][0]

    def add_ports_versions_to_results(self, ports_data):
        
        for x in self.info_gather_results:
            if x['dest_host'] == ports_data['target']:
                x['ports'].clear()
                for port in ports_data['ports']:
                    x['ports'].append(port)


    def get_ip_info(self, selected_ip):
        
        # for x in self.info_gather_results:
        #     if x['dest_host'] == selected_ip:
        #         tempDict = dict(user_id=self.user_id, eventType='requested_ip_data_sent', data=x)
        #         print(tempDict)
        #         self.web_socket.send(json.dumps(tempDict))

        ip_data_dict = {}
        for x in self.info_gather_results:
            if x['dest_host'] == selected_ip:
                
                for k, v in x.items():
                    if k != 'ports':
                        ip_data_dict[k] = v

                tempDict = dict(user_id=self.user_id, eventType='requested_ip_data_sent', data=ip_data_dict)
                self.web_socket.send(json.dumps(tempDict))


                for k, v in x.items():
                    if k == 'ports':
                        indexes_list = [0]
                        ports_list = []
                        chunk_size = 0
                        num_of_chunks = 0
                        indexes_count = 0

                        for port in x['ports']:
                            indexes_count += 1
                            ports_list.append(port)

                            size = get_size(ports_list)
                            chunk_size += size

                            if chunk_size >= 64000:
                                ports_list.clear()
                                num_of_chunks += 1
                                chunk_size = 0
                                indexes_list.append(indexes_count)

                        if not len(x['ports']) in indexes_list:
                            num_of_chunks += 1
                            indexes_list.append(len(x['ports']))
                        

                        for i in range(0, len(indexes_list)-1):
                            ports = x['ports'][indexes_list[i]:indexes_list[i+1]]
                            data_dict = dict(dest_host=x['dest_host'], ports=ports)
                            tempDict2 = dict(user_id=self.user_id, total_data_chunks=num_of_chunks, eventType='requested_ip_ports_data_sent', data=data_dict)
                            self.web_socket.send(json.dumps(tempDict2))

    
    # def get_ip_ports_data(self, ips_list):

    #     if self.information_gathering_status == 'Finished':    
    #         self.sub_module = ''
            
    #         data_list = []
    #         results_db_path = './results.db'
    #         if os.path.exists(results_db_path):
    #             conn = sqlite3.connect(results_db_path)

    #             cursor = conn.cursor()

    #             for ip in ips_list:
    #                 # query = "SELECT * from ports INNER JOIN os on os.dest_host = ports.dest_host where dest_host = " + ip['ip'] + ";"
    #                 query = "SELECT port, service, service_version_display, vendor_product_name, version, info, hostname, operating_system, device_type, os_name from ports INNER JOIN os on os.dest_host = ports.dest_host where ports.dest_host = '" + ip['ip'] + "';"
    #                 cursor.execute(query)
    #                 ports_results = cursor.fetchall()

    #                 if len(ports_results) > 0:
    #                     ports_dict = dict(ip=ip['ip'], os=ports_results[0][9], ports=ports_results)
                    
    #                 data_list.append(ports_dict)

    #                 conn.commit()

    #             conn.close()


    #         else:
    #             print("Results DB not found. Cannot get Ports data")
                
    #             exit()
            
    #         ports_data_list = []
    #         for data in data_list:
    #             data_dict = {}
    #             data_dict['ip'] = data['ip']
    #             data_dict['os'] = data['os']
    #             data_dict['ports'] = []
    #             for port_res in data['ports']:    
    #                 tempDict = dict(port=port_res[1], service=port_res[2], service_version_display=port_res[3], vendor_product_name=port_res[4], version=port_res[5], info=port_res[6], hostname=port_res[7], operating_system=port_res[8], device_type=port_res[9])
    #                 data_dict['ports'].append(tempDict)
                
    #             ports_data_list.append(data_dict)

    #         # info_gather_dict = {}
    #         # for port_res in ports_results:
    #         #     if not port_res[0] in info_gather_dict.keys():
    #         #         info_gather_dict['os'] = port_res[11]
    #         #         info_gather_dict[port_res[0]] = []
                    
    #         #     # tempDict = dict(port=port_res[1], status=port_res[2], service=port_res[3], service_version_display=port_res[4], vendor_product_name=port_res[5], version=port_res[6], info=port_res[7], hostname=port_res[8], operating_system=port_res[9], device_type=port_res[10])
    #         #     tempDict = dict(port=port_res[1], service=port_res[2], service_version_display=port_res[3], vendor_product_name=port_res[4], version=port_res[5], info=port_res[6], hostname=port_res[7], operating_system=port_res[8], device_type=port_res[9])
    #         #     info_gather_dict[port_res[0]].append(tempDict)
            

    #         tempDict2 = dict(user_id=self.user_id, eventType='requested_ip_ports_data_sent', data=ports_data_list)
    #         self.web_socket.send(json.dumps(tempDict2))

    def get_ip_vulnerabilities(self, ip):

        ip_vulns_list = []
        results_db_path = './results.db'
        if os.path.exists(results_db_path):
            conn = sqlite3.connect(results_db_path)

            cursor = conn.cursor()

            query = "SELECT * from vulnerabilities where ip == '" + ip + "';"
            
            cursor.execute(query)
            ip_vulnerabilities = cursor.fetchall()
            
            chunk_size = 0
            num_of_chunks = 1
            indexes_list = [0]
            indexes_count = 0
            for vul in ip_vulnerabilities:

                indexes_count += 1

                if vul[8] != -1:
                    severity = vul[7]
                    severity_text = vul[8]
                    cvss_version = 'CVSS V3'
                elif vul[6] != -1:
                    severity = vul[5]
                    severity_text = vul[6]
                    cvss_version = 'CVSS V2'
                else:
                    severity = '0'
                    severity_text = 'None'
                    cvss_version = 'None'
                
                tempDict = dict(port=vul[1], service=vul[3], cve_id=vul[4], cvss_v2=vul[6], cvss_v2_severity=vul[7], 
                                cvss_v3=vul[8], cvss_v3_severity=vul[9], severity=severity, severity_text=severity_text, cvss_version=cvss_version)
                ip_vulns_list.append(tempDict)

                size = get_size(tempDict)
                chunk_size += size

                if chunk_size >= 64000:
                    num_of_chunks += 1
                    chunk_size = 0
                    indexes_list.append(indexes_count)

            indexes_list.append(len(ip_vulns_list))


            ####### SAJJAD ########################### 

            cur = conn.cursor()

            query = "SELECT * from vulnerabilities_manual where ip == '" + ip + "';"
            
            cur.execute(query)
            ip_vulnerabilities = cur.fetchall()
            
            chunk_size = 0
            num_of_chunks = 1
            indexes_list = [0]
            indexes_count = 0
            for vul in ip_vulnerabilities:

                indexes_count += 1

                if vul[8] != -1:
                    severity = vul[7]
                    severity_text = vul[8]
                    cvss_version = 'CVSS V3'
                elif vul[6] != -1:
                    severity = vul[5]
                    severity_text = vul[6]
                    cvss_version = 'CVSS V2'
                else:
                    severity = '0'
                    severity_text = 'None'
                    cvss_version = 'None'
                
                tempDict = dict(port=vul[1], service=vul[3], cve_id=vul[4], cvss_v2=vul[6], cvss_v2_severity=vul[7], 
                                cvss_v3=vul[8], cvss_v3_severity=vul[9], severity=severity, severity_text=severity_text, cvss_version=cvss_version)
                ip_vulns_list.append(tempDict)

                size = get_size(tempDict)
                chunk_size += size

                if chunk_size >= 64000:
                    num_of_chunks += 1
                    chunk_size = 0
                    indexes_list.append(indexes_count)

            indexes_list.append(len(ip_vulns_list))
            
            ####### SAJJAD ########################### 
            
            for i in range(0, len(indexes_list)-1):
                dataDict = dict(ip=ip, vulnerabilities=ip_vulns_list[indexes_list[i]:indexes_list[i+1]])
                tempDict2 = dict(user_id=self.user_id, total_data_chunks=num_of_chunks, eventType='requested_ip_vulnerability_details_sent', data=dataDict)
                self.web_socket.send(json.dumps(tempDict2))
    

    def get_vulnerability_details(self, data):
        
        ip =  data['ip']
        cve_id = data['cve_id']
        port = data['port']

        results_db_path = './results.db'
        if os.path.exists(results_db_path):

            conn = sqlite3.connect(results_db_path)

            cursor = conn.cursor()

            query = "SELECT * from vulnerabilities where ip ='" + ip + "' and cve_id='" + cve_id + "' and port='" + port + "'"; 
            cursor.execute(query)
            ports_results = cursor.fetchone()

            if ports_results != None:
            
                ip = ports_results[0]
                port = ports_results[1]
                service = ports_results[2]
                cve_id = ports_results[4]
                description = ports_results[5]
                cvss_v2 = ports_results[6]
                cvss_v2_severity = ports_results[7]
                cvss_v3 = ports_results[8]
                cvss_v3_severity = ports_results[9]
                exploit_resources = ports_results[10]
                patch_resources = ports_results[11]
                published_date = ports_results[12]
                last_modified_date = ports_results[13]
                assigner = ports_results[14]
                cve_data_timestamp = ports_results[15]
                cwe_id = ports_results[16]

                tempDict = dict(ip=ip, port=port, service=service, cve_id=cve_id, description=description,
                                cvss_v2=cvss_v2, cvss_v2_severity=cvss_v2_severity, cvss_v3=cvss_v3,
                                cvss_v3_severity=cvss_v3_severity, exploit_resources=exploit_resources,
                                patch_resources=patch_resources, published_date=published_date, last_modified_date=last_modified_date,
                                assigner=assigner, cve_data_timestamp=cve_data_timestamp, cwe_id=cwe_id)


                tempDict2 = dict(user_id=self.user_id, eventType='requested_vulnerability_details_sent', data=tempDict)
                self.web_socket.send(json.dumps(tempDict2))                
            
            ####### SAJJAD ########################### 
            
            conn = sqlite3.connect(results_db_path)

            cursor = conn.cursor()

            query = "SELECT * from vulnerabilities_manual where ip ='" + ip + "' and port='" + port + "'"; 
            cursor.execute(query)
            ports_results = cursor.fetchone()

            if ports_results !=None:
            
                ip = ports_results[0]
                port = ports_results[1]
                service = ports_results[2]
                cve_id = ports_results[4]
                description = ports_results[5]
                cvss_v2 = ports_results[6]
                cvss_v2_severity = ports_results[7]
                cvss_v3 = ports_results[8]
                cvss_v3_severity = ports_results[9]
                exploit_resources = ports_results[10]
                patch_resources = ports_results[11]
                published_date = ports_results[12]
                last_modified_date = ports_results[13]
                assigner = ports_results[14]
                cve_data_timestamp = ports_results[15]
                cwe_id = ports_results[16]

                tempDict = dict(ip=ip, port=port, service=service, cve_id=cve_id, description=description,
                                cvss_v2=cvss_v2, cvss_v2_severity=cvss_v2_severity, cvss_v3=cvss_v3,
                                cvss_v3_severity=cvss_v3_severity, exploit_resources=exploit_resources,
                                patch_resources=patch_resources, published_date=published_date, last_modified_date=last_modified_date,
                                assigner=assigner, cve_data_timestamp=cve_data_timestamp, cwe_id=cwe_id)
                

                tempDict2 = dict(user_id=self.user_id, eventType='requested_vulnerability_details_sent', data=tempDict)
                self.web_socket.send(json.dumps(tempDict2))  

            ####### SAJJAD ########################### 
            
          

    def write_scan_details_to_db(self, scan_data):
        
        results_db_path = './results.db'

        if os.path.exists(results_db_path):
            os.remove(results_db_path)

        con = sqlite3.connect(results_db_path)
        cur = con.cursor()
        
        # Create table
        try:
            cur.execute('''CREATE TABLE if not exists scan_details (user_input text, host_discovery text, port_scanning text, scan_type text, 
                                                                    interface text, mode text)''')
        except Exception as e:
            print(e)

        scan_data = (scan_data['ip'],scan_data['scanSettings']['hostDiscovery'],scan_data['scanSettings']['portScanning'],
                    scan_data['scanSettings']['scanType'],scan_data['scanSettings']['interface'],scan_data['scanSettings']['mode'])

        cmd = 'insert into scan_details values(?, ?, ?, ?, ?, ?)'
        
        cur.execute(cmd, scan_data)
        con.commit()           
        
    def write_info_gather_results_to_db(self):
        
        results_db_path = './results.db'

        results_list = []
        os_list = []
        con1 = sqlite3.connect(results_db_path)
        cur1 = con1.cursor()
        
        # Create table
        try:
            cur1.execute('''CREATE TABLE hosts (dest_host text, mac_addr text, mac_vendor text, host_name text)''')
        except Exception as e:
            print(e)
        
        cur1.executemany("insert into hosts values (:dest_host, :mac_addr, :mac_vendor, :host_name)", self.info_gather_results)
        con1.commit()

        for x in self.info_gather_results:
            if len(x['ports']):
                for y in x['ports']:
                    if 'version' in y.keys():
                        if bool (y['version']):
                            service_version_display = y['version']['service_version_display']
                            vendor_product_name = y['version']['vendor_product_name']
                            version = y['version']['version']
                            info = y['version']['info'] 
                            hostname = y['version']['hostname']
                            operating_system = y['version']['operating_system']
                            device_type = y['version']['device_type']
                        else:
                            service_version_display = ''
                            vendor_product_name = ''
                            version = ''
                            info = '' 
                            hostname = ''
                            operating_system = ''
                            device_type = ''

                    else:
                        service_version_display = ''
                        vendor_product_name = ''
                        version = ''
                        info = '' 
                        hostname = ''
                        operating_system = ''
                        device_type = ''
                        
                    tempDict = dict(dest_host=x['dest_host'], port=y['port'], 
                                        service=y['service'], service_version_display=service_version_display,
                                        vendor_product_name=vendor_product_name, version=version, info=info, 
                                        hostname=hostname, operating_system=operating_system, device_type=device_type)
                    results_list.append(tempDict)
            
            else:   #TODO: Improve code structure here
                tempDict = dict(dest_host=x['dest_host'], port='', status='', 
                                    service='', service_version_display='',
                                    vendor_product_name='', version='', info='', 
                                    hostname='', operating_system='', device_type='')
                results_list.append(tempDict)

            if 'os' in x.keys():
                if bool (x['os']):
                    osDict = dict(ip=x['dest_host'], os_name=x['os']['os_name'])
                    os_list.append(osDict)
                else:
                    osDict = dict(ip=x['dest_host'], os_name='Unknown')
                    os_list.append(osDict)
            else:
                osDict = dict(ip=x['dest_host'], os_name='Unknown')
                os_list.append(osDict)

        con2 = sqlite3.connect(results_db_path)
        cur2 = con2.cursor()
        # Create table
        try:
            cur2.execute('''CREATE TABLE os (dest_host text, os_name text)''')
        except Exception as e:
            print(e)
        
        cur2.executemany("insert into os values (:ip, :os_name)", os_list) 
        con2.commit()

        con3 = sqlite3.connect(results_db_path)
        cur3 = con3.cursor()
        # Create table
        try:
            cur3.execute('''CREATE TABLE ports (dest_host text, port text, service text, service_version_display text, vendor_product_name text, version text, info text, hostname text, operating_system text, device_type text)''')
        except Exception as e:
            print(e)
        
        cur3.executemany("insert into ports values (:dest_host, :port, :service, :service_version_display, :vendor_product_name, :version, :info, :hostname, :operating_system, :device_type)", results_list)
        con3.commit()
        
        con1.close()
        con2.close()
        con3.close()

    def write_vulnerabilities_result_to_db(self, vulns, ip):

        vulns_list = []
        manual_list = []
        for v in vulns:
            for vulnerabilities in v['vulnerabilities']:
                try:
                    cvss_v2 = float(vulnerabilities['cvss_v2'])
                except:
                    cvss_v2 = -1

                try:
                    cvss_v3 = float(vulnerabilities['cvss_v3'])
                except:
                    cvss_v3 = -1

                tempDict = dict(ip=ip, port=v['port_info']['port'], service=v['port_info']['service'], service_version=v['port_info']['service_version_display'],
                            cve_id=vulnerabilities['cve_id'], description=vulnerabilities['description'], 
                            cvss_v2=cvss_v2, cvss_v2_severity=vulnerabilities['cvss_v2_severity'], 
                            cvss_v3=cvss_v3, cvss_v3_severity=vulnerabilities['cvss_v3_severity'], 
                            exploit_resources=vulnerabilities['exploit_resources'], patch_resources=vulnerabilities['patch_resources'],
                            published_date=vulnerabilities['published_date'], last_modified_date=vulnerabilities['last_modified_date'],
                            assigner=vulnerabilities['assigner'], cve_data_timestamp=vulnerabilities['cve_data_timestamp'],
                            cwe_id=vulnerabilities['cwe_id'])
                            
                vulns_list.append(tempDict)

        results_db_path = './results.db'

        con = sqlite3.connect(results_db_path)
        cur = con.cursor()
        
        # Create table
        try:
            cur.execute('''CREATE TABLE if not exists vulnerabilities (ip text, port text, service text, service_version text, cve_id text, description text, 
                                                                        cvss_v2 real, cvss_v2_severity text, cvss_v3 real, cvss_v3_severity text, 
                                                                        exploit_resources text, patch_resources text, published_date text, last_modified_date text,
                                                                        assigner text, cve_data_timestamp text, cwe_id text)''')
        except Exception as e:
            print(e)
        
        cur.executemany('''insert into vulnerabilities values (:ip, :port, :service, :service_version, :cve_id, :description, :cvss_v2, :cvss_v2_severity, :cvss_v3, 
                                                                :cvss_v3_severity, :exploit_resources, :patch_resources, :published_date,
                                                                :last_modified_date, :assigner, :cve_data_timestamp, :cwe_id)''', vulns_list)

        con.commit()

        con.close()

    def write_vulnerabilities_manual_result_to_db(self, vulns, ip):

        vulns_list = []
        manual_list = []
        for v in vulns:
            for vulnerabilities in v['vulnerabilities']:
                try:
                    cvss_v2 = float(vulnerabilities['cvss_v2'])
                except:
                    cvss_v2 = -1

                try:
                    cvss_v3 = float(vulnerabilities['cvss_v3'])
                except:
                    cvss_v3 = -1
                
                tempDict = dict(ip=ip, port=v['port_info']['port'], service=v['port_info']['service'], service_version=v['port_info']['service_version_display'],
                            cve_id=vulnerabilities['cve_id'], description=vulnerabilities['description'], 
                            cvss_v2=cvss_v2, cvss_v2_severity=vulnerabilities['cvss_v2_severity'], 
                            cvss_v3=cvss_v3, cvss_v3_severity=vulnerabilities['cvss_v3_severity'], 
                            exploit_resources=vulnerabilities['exploit_resources'], patch_resources=vulnerabilities['patch_resources'],
                            published_date=vulnerabilities['published_date'], last_modified_date=vulnerabilities['last_modified_date'],
                            assigner=vulnerabilities['assigner'], cve_data_timestamp=vulnerabilities['cve_data_timestamp'],
                            cwe_id=vulnerabilities['cwe_id'], exploit_number=vulnerabilities['exploit_number'], os_name=vulnerabilities['os_name'])
                            
                manual_list.append(tempDict) 


        results_db_path = './results.db'

        con = sqlite3.connect(results_db_path)
        cur = con.cursor()
        
        # Create table
        try:
            cur.execute('''CREATE TABLE if not exists vulnerabilities_manual (ip text, port text, service text, service_version text, cve_id text, description text, 
                                                                        cvss_v2 real, cvss_v2_severity text, cvss_v3 real, cvss_v3_severity text, 
                                                                        exploit_resources text, patch_resources text, published_date text, last_modified_date text,
                                                                        assigner text, cve_data_timestamp text, cwe_id text, exploit_number text, os_name text)''')
        except Exception as e:
            print(e)
        
        cur.executemany('''insert into vulnerabilities_manual values (:ip, :port, :service, :service_version, :cve_id, :description, :cvss_v2, :cvss_v2_severity, :cvss_v3, 
                                                                :cvss_v3_severity, :exploit_resources, :patch_resources, :published_date,
                                                                :last_modified_date, :assigner, :cve_data_timestamp, :cwe_id, :exploit_number, :os_name)''', manual_list)

        con.commit()

        con.close()    

    def write_module_time_to_db(self, module, module_start_time, module_completion_time, module_elapsed_time):
        results_db_path = './results.db'


        con = sqlite3.connect(results_db_path)
        cur = con.cursor()
        
        # Create table
        try:
            cur.execute('''CREATE TABLE if not exists module_timestamps (module text, start_time text, finish_time text, elapsed_time text)''')
        except Exception as e:
            print(e)

        scan_data = (module, module_start_time, module_completion_time, module_elapsed_time)

        cmd = 'insert into module_timestamps values(?, ?, ?, ?)'
        
        cur.execute(cmd, scan_data)
        con.commit()  
