import os
import sqlite3
import socket
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import multiprocessing
import ssl
import threading
import multiprocessing
import regex

class TimeOutException(Exception):
   pass

def get_probes(port):

    services_db_path = os.getcwd() + '/service_version_enumeration/services_probes.db'

    if os.path.exists(services_db_path):

        conn = sqlite3.connect(services_db_path)

        cursor = conn.cursor()

        query = "SELECT * from probes where ports LIKE '%,"+ str(port) +",%' OR ports LIKE '"+ str(port) +",%' OR ports LIKE '%,"+ str(port) + "' OR ports = " + str(port) + " OR probe_id == 'TCP NULL q||'"
        cursor.execute(query)

        probes = cursor.fetchall()

        query = "SELECT * from probes where sslports LIKE '%,"+ str(port) +",%' OR sslports LIKE '"+ str(port) +",%' OR sslports LIKE '%,"+ str(port) + "' OR sslports = " + str(port) + " OR probe_id == 'TCP NULL q||'"
        cursor.execute(query)

        ssl_probes = cursor.fetchall()

        conn.commit()

        conn.close()

        probes_list = []
        for probe in probes:
            probe_dict = dict(probe_id=probe[0], probe_name=probe[1], probe_protocol=probe[2], probe_payload=probe[3], rarity=probe[4], ports=probe[5], sslports=probe[6], fallback=probe[7], totalwaitms=probe[8], tcpwrappedms=probe[9], port_flag='port')
            probes_list.append(probe_dict)

        ssl_probes_list = []
        for probe in ssl_probes:
            probe_dict = dict(probe_id=probe[0], probe_name=probe[1], probe_protocol=probe[2], probe_payload=probe[3], rarity=probe[4], ports=probe[5], sslports=probe[6], fallback=probe[7], totalwaitms=probe[8], tcpwrappedms=probe[9], port_flag='sslport')
            ssl_probes_list.append(probe_dict)

        return probes_list, ssl_probes_list

def get_all_tcp_probes():

    services_db_path = os.getcwd() + '/service_version_enumeration/services_probes.db'

    if os.path.exists(services_db_path):

        conn = sqlite3.connect(services_db_path)

        cursor = conn.cursor()

        query = "SELECT * from probes where probe_id != 'TCP NULL q||' AND probe_protocol = 'TCP' AND rarity<8;"
        cursor.execute(query)

        probes = cursor.fetchall()

        conn.commit()

        conn.close()

        all_probes_list = []
        for probe in probes:
            probe_dict = dict(probe_id=probe[0], probe_name=probe[1], probe_protocol=probe[2], probe_payload=probe[3], rarity=probe[4], ports=probe[5], sslports=probe[6], fallback=probe[7], totalwaitms=probe[8], tcpwrappedms=probe[9], port_flag='port')
            all_probes_list.append(probe_dict)


        return all_probes_list

def create_socket():
    pass
def send_payload(target, port, probe):

    payload = probe['probe_payload']

    payload = payload.encode()

    payload = payload.decode('unicode-escape')
    
    payload = payload.encode('latin-1')
    
    port_flag = probe['port_flag']

    recv_data = b''

    if probe['probe_protocol'] == 'TCP':
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        if probe['totalwaitms'] != '':
            time_out = int(probe['totalwaitms']) / 1000 # convert miliseconds to seconds
            sock.settimeout(time_out)
        else:
            sock.settimeout(5)

        start_time = datetime.now()

        if port_flag == 'sslport':
            try:
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                sock = context.wrap_socket(sock, server_hostname=target)            
            except Exception as e:
                print(e)


        try:
            sock.connect((target, port))
            sock.sendall(payload)
            while True:
                data = sock.recv(4096)
                recv_data += data
                if not data:
                    break
            sock.close()

        except socket.timeout:
            sock.close()
            
        except ConnectionResetError:
            if probe['tcpwrappedms'] != '':
                tcp_wrapped_time_out = float(probe['tcpwrappedms']) / 1000 # convert miliseconds to seconds
                current_time = datetime.now()
                time_diff = (current_time - start_time).total_seconds()
                if time_diff < tcp_wrapped_time_out:
                    sock.close()
                    recv_data = b'tcpwrapped'
            
            else:
                sock.close()
            

        except Exception as e:
            print(port)
            print(e)
            print("************************************")
            sock.close()

    return recv_data

def send_payload_ssl():
    pass

def alarm_handler(signum, frame):
    print("ALARM signal received")
    raise TimeOutException()

def re_search(db_pattern, res, ignore_case):
    if ignore_case:
        match = re.search(db_pattern, res, re.IGNORECASE)
    else:
        match =re.search(db_pattern, res)

    return match

def match_from_db(probe, res):

    re_vendor_product_name = r'(\sp/(.+?)/)|(\sp\|(.+?)\|)'
    re_version = r'(\sv/(.+?)/)|(\sv\|(.+?)\|)'
    re_info = r'(\si/(.+?)/)|(\si\|(.+?)\|)'
    re_hostname = r'(\sh/(.+?)/)|(\sh\|(.+?)\|)'
    re_operating_system = r'(\so/(.+?)/)|(\so\|(.+?)\|)'
    re_device_type = r'(\sd/(.+?)/)|(\sd\|(.+?)\|)'
    # re_cpe = r'cpe:/'

    try:
        res = res.decode('unicode-escape', errors='ignore')

    except Exception as e:
        print(e)

    services_db_path = os.getcwd() + '/service_version_enumeration/services_probes.db'

    if os.path.exists(services_db_path):

        conn = sqlite3.connect(services_db_path)

        cursor = conn.cursor()

        query = "SELECT * from probe_matches where probe_name = '" + probe['probe_name'] + "' OR probe_name = '" + probe['fallback'] + "' OR probe_name='NULL';"
        cursor.execute(query)

        probes = cursor.fetchall()

    for probe in probes:
        
            
        db_pattern_length = len(probe[4])
        
        db_pattern = probe[4][2:db_pattern_length-1]
        
        found_matches = None

        v_info = probe[5]
        v_info_length = len(v_info)
        v_info = v_info.rjust(v_info_length+1)

        vendor_product_name = ''
        version = ''
        info = ''
        hostname = ''
        operating_system = ''
        device_type = ''
        # cpe = ''
        
        
        try:
            if probe[6] == 's':
                if regex.search(db_pattern, res, regex.IGNORECASE|regex.DOTALL):
                    found_matches = re.findall(db_pattern, res, re.IGNORECASE|re.DOTALL)[0]


            else:
                if regex.search(db_pattern, res, regex.DOTALL):
                    found_matches = re.findall(db_pattern, res, re.DOTALL)[0]
        except Exception as e:
            pass
            # print('     [-] ',e)

        if found_matches:
            

            if type(found_matches) == tuple:
                for i in range(0, len(found_matches)):
                    v_info = v_info.replace('$'+str(i+1), found_matches[i])

                    if '$P('+str(i+1)+')' in v_info:
                        found_match = found_matches[i].encode('ascii', errors='ignore').decode('utf-16','ignore')
                        v_info = v_info.replace('$P('+str(i+1)+')', found_match)

            else:
                v_info = v_info.replace('$'+str(1), found_matches)

                if '$P('+str(1)+')' in v_info:

                    found_match = found_matches.encode('ascii', errors='ignore').decode('utf-16','ignore')
                    v_info = v_info.replace('$P('+str(1)+')', found_match)


            try:
                vendor_product_name = re.search(re_vendor_product_name, v_info).group(0).strip()[2:-1]
            except:
                vendor_product_name = ''
            try:
                version = re.search(re_version, v_info).group(0).strip()[2:-1]
            except:
                version = ''
            try:
                info = re.search(re_info, v_info).group(0).strip()[2:-1]
            except:
                info = ''
            try:
                hostname = re.search(re_hostname, v_info).group(0).strip()[2:-1]
            except:
                hostname = ''
            try:
                operating_system = re.search(re_operating_system, v_info).group(0).strip()[2:-1]
            except:
                operating_system = ''
            try:
                device_type = re.search(re_device_type, v_info).group(0).strip()[2:-1]
            except:
                device_type = ''
            
            if info != '':         
                service_version_display = vendor_product_name + ' ' + version + ' (' + info + ')'
            else:
                service_version_display = vendor_product_name + ' ' + version

            service_version_display = service_version_display.strip()
            
            tempDict = dict(service_version_display=service_version_display, vendor_product_name=vendor_product_name, version=version, info=info, hostname=hostname, operating_system=operating_system, device_type=device_type, matched_proto=probe[3])
            return tempDict

def version_detection_thread(port_status, target):
    
    try:
        port = port_status['port']
        port_status['version'] = {}

        probes_list, ssl_probes_list = get_probes(port)

        payload_response = b''
        is_port_ssl = False
        for probe in probes_list:
            payload_response = send_payload(target, port, probe)
            if payload_response != b'':
                service_version =  match_from_db(probe, payload_response)
                if service_version:

                    if service_version['matched_proto'] == 'ssl':
                        is_port_ssl = True
                        break
                    
                    else:
                        print(port)
                        port_status['version'] = service_version
                        port_status['service'] =  service_version['matched_proto']
                        print(service_version)
                        break

        
        if payload_response == b'':
            all_probes_list = get_all_tcp_probes()
            for probe in all_probes_list:
                payload_response = send_payload(target, port, probe)
                if payload_response:
                    service_version =  match_from_db(probe, payload_response)
                    if service_version:
                        
                        if service_version['matched_proto'] == 'ssl':
                            is_port_ssl = True
                            break
                        
                        else:
                            print(port)
                            port_status['version'] = service_version
                            port_status['service'] =  service_version['matched_proto']
                            print(service_version)
                            break
                        

        if is_port_ssl:
            for probe in ssl_probes_list:
                payload_response = send_payload(target, port, probe)
                if payload_response:
                    service_version =  match_from_db(probe, payload_response)
                    if service_version:

                        if not service_version['vendor_product_name'] == '':
                            print(port)
                            port_status['version'] = service_version
                            print(service_version)
                            break
    except Exception as e:
        print('qwerty', e)
        
def version_detection(info_gather=None, ports_data=None):
    
    
    ports_list = ports_data['ports']

    target = ports_data['target']

    module = 'Port Version Detection'
    sub_module = ''
    event_type = 'ports_version_detection_started'
    info_gather.send_module_time_to_server(module, sub_module, event_type, None, None, target)

    # for port_status in ports_list:

    #     version_detection_thread(port_status, target)
    num_of_thread = multiprocessing.cpu_count() * 5
    with ThreadPoolExecutor(num_of_thread) as executor:
            for port_status in ports_list:
                executor.submit(version_detection_thread, port_status, target)

    module = 'Port Version Detection'
    sub_module = ''
    event_type = 'ports_version_detection_finished'
    info_gather.send_module_time_to_server(module, sub_module, event_type, None, None, target)

    return ports_data

if __name__ == '__main__':


    target = '206.84.134.217'
    # ports_list = [{'port':21},{'port':22},{'port':23},{'port':80},{'port':5431}]
    # ports_list = [{'port':5000},{'port':10002},{'port':10004},{'port':10009},{'port':10012}]
    # ports_list = [{'port':80}]
    # ports_list = [{'port':5000},{'port':10009}]
    ports_list = [{'port':5000}]
    tempDict = dict(target=target, ports=ports_list)
    version_detection(None, tempDict)
    

