import binascii
import select
import socket
from struct import *
import time
import struct
import codecs


SMB_DIALECT = b'\x02NT LM 0.12\x00'
CAP_EXTENDED_SECURITY = 0x80000000
CAP_USE_NT_ERRORS = 0x40
CAP_NT_SMBS = 0x10
CAP_LARGE_READX = 0x00004000
CAP_LARGE_WRITEX = 0x00008000
CAP_UNICODE = 0x0004

NTLMSSP_NEGOTIATE_128 = 0x20000000
NTLMSSP_NEGOTIATE_NTLM = 0x00000200
NTLMSSP_NEGOTIATE_UNICODE = 0x00000001
NTLMSSP_NEGOTIATE_TARGET_INFO = 0x00800000
NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY = 0x00080000
NTLMSSP_REQUEST_TARGET = 0x00000004
NTLMSSP_NEGOTIATE_56 = 0x80000000

NTLMSSP_NEGOTIATE = 0x00000001

GSS_API_SPNEGO_UUID = b'\x2b\x06\x01\x05\x05\x02'

MechTypes = {
b'+\x06\x01\x04\x01\x827\x02\x02\n': 'NTLMSSP - Microsoft NTLM Security Support Provider',
b'*\x86H\x82\xf7\x12\x01\x02\x02': 'MS KRB5 - Microsoft Kerberos 5',
b'*\x86H\x86\xf7\x12\x01\x02\x02': 'KRB5 - Kerberos 5',
b'*\x86H\x86\xf7\x12\x01\x02\x02\x03': 'KRB5 - Kerberos 5 - User to User',
b'\x2b\x06\x01\x04\x01\x82\x37\x02\x02\x1e': 'NEGOEX - SPNEGO Extended Negotiation Security Mechanism'
}

TypesMech = dict((v,k) for k, v in MechTypes.items())

class Packet:

    def __init__(self):
        self.time_out = 0.5

    def generateIPHeader(self,s_ip,d_ip):
        #IP Header
        self.version=0x4
        self.ihl=0x5
        self.type_of_service=0x0
        self.total_length=0x28
        self.identification=0x0001
        self.flags=0x0
        self.fragment_offset=0x0
        self.ttl=0x40
        self.protocol=0x6
        self.header_checksum=0x0
        self.src_ip=s_ip
        self.dest_ip=d_ip
        
        self.src_addr=socket.inet_aton(self.src_ip)
        self.dest_addr=socket.inet_aton(self.dest_ip)
        
        self.version_ihl=((self.version<<4)+self.ihl)
        self.f_fo=((self.flags<<13)+self.fragment_offset)
        self.v_ihl_tos=(self.version<<12)+(self.ihl<<8)+self.type_of_service
        self.ttl_proto=(self.ttl<<8)+self.protocol
        octets=self.src_ip.split('.')
        num1=int(octets[0])
        num2=int(octets[1])
        num3=int(octets[2])
        num4=int(octets[3])
        self.src_addr1=(num1<<8)+num2
        self.src_addr2=(num3<<8)+num4

        octets=self.dest_ip.split('.')
        num1=int(octets[0])
        num2=int(octets[1])
        num3=int(octets[2])
        num4=int(octets[3])
        self.dest_addr1=(num1<<8)+num2
        self.dest_addr2=(num3<<8)+num4

        subtotal=self.v_ihl_tos+self.total_length+self.identification+self.f_fo+self.ttl_proto+self.src_addr1+self.src_addr2+self.dest_addr1+self.dest_addr2
        self.header_checksum=(0xffff)-((subtotal>>16)+(subtotal & 0xffff))
        self.ip_header=pack("!BBHHHBBH4s4s",self.version_ihl,self.type_of_service,self.total_length,self.identification
                                ,self.f_fo,self.ttl,self.protocol,self.header_checksum,self.src_addr,self.dest_addr)

        return self.ip_header
        

    def generateTCPHeader(self,s_port,d_port, ns=0x0,cwr=0x0,ece=0x0,urg=0x0,ack=0x0,psh=0x0,rst=0x0,syn=0x0,fin=0x0):
        #TCP Segment
        self.tcp_protocol=0x6
        self.tcp_length=0x14
        self.src_port=int(s_port)
        self.dest_port=int(d_port)
        self.seq_no=0x0
        self.ack_no=0x0
        self.data_offset=0x5
        self.reserved=0x0
        self.ns=ns
        self.cwr=cwr
        self.ece=ece
        self.urg=urg
        self.ack=ack
        self.psh=psh
        self.rst=rst
        self.syn=syn
        self.fin=fin
        
        self.window_size=0x7110
        self.checksum=0x0
        self.urg_pointer=0x0
        self.data_offset_res_flags=(self.data_offset<<12)+(self.reserved<<9)+(self.ns<<8)+(self.cwr<<7)+(self.ece<<6)+(self.urg<<5)+(self.ack<<4)+(self.psh<<3)+(self.rst<<2)+(self.syn<<1)+self.fin
        tcp_subtotal=self.tcp_protocol+self.src_addr1+self.src_addr2+self.dest_addr1+self.dest_addr2+self.tcp_length+self.src_port+self.dest_port+self.seq_no+self.ack_no+self.data_offset_res_flags+self.window_size+self.urg_pointer
        self.checksum=(0xffff)-((tcp_subtotal>>16)+(tcp_subtotal & 0xffff))
    
        
        self.tcp_header=pack("!HHLLHHHH",self.src_port,self.dest_port,self.seq_no,self.ack_no,self.data_offset_res_flags,
                        self.window_size,self.checksum,self.urg_pointer)
        
        return self.tcp_header
        
    def generateICMPHeader(self, identifier):

        #########################################
        #|Type      |Code       |Checksum       |
        #|(8bits)   |(8bits)    |(16bits)       |
        #----------------------------------------
        #|Identifier      |Checksum             |       
        #|(16bits)        |(16bits)             |
        #########################################

        self.type=0x8
        self.code=0x0
        self.checksum=0x0
        self.own_id=identifier
        self.seq_number=0x0

        self.type_code=(self.type<<8)+self.code
        icmp_subtotal=self.type_code+self.checksum+self.own_id+self.seq_number
        self.checksum=(0xffff)-((icmp_subtotal>>16)+(icmp_subtotal & 0xffff))
        
        icmp_header =pack("!BBHHH", self.type, self.code, self.checksum, self.own_id, self.seq_number)
        return icmp_header
    
    
    def generateARPHeader(self, source_mac, source_ip,dest_ip):
        
        #Ethernet Header
        self.source_mac=binascii.unhexlify(source_mac.replace(':','')) 
        self.dest_mac=b'\xff\xff\xff\xff\xff\xff' 
        self.protocol=0x0806
        self.eth_header=pack("!6s6sH", self.dest_mac,self.source_mac,self.protocol)

        #ARP Header
        self.source_ip=source_ip
        self.dest_ip=dest_ip
        self.htype=1
        self.ptype=0x0800
        self.hlen=6
        self.plen=4
        self.operation=1
        self.s_ip=socket.inet_aton(self.source_ip)
        self.d_ip=socket.inet_aton(self.dest_ip)
        self.dest_mac=b'\x00\x00\x00\x00\x00\x00'
        self.arp_header=pack("!HHBBH6s4s6s4s", self.htype, self.ptype, self.hlen, self.plen, self.operation, self.source_mac, self.s_ip, self.dest_mac, self.d_ip)

        arp_packet = self.eth_header + self.arp_header

        return arp_packet

    def netbios_session_service(self, length):
        self.message_type = 0x00
        self.length = length

        # self.nb_session_header = pack("!BH",self.message_type, self.length)
        # self.nb_session_header = pack('!BBH', self.message_type, self.flags, self.length)

        self.nb_session_header  = pack('!BBH', self.message_type, self.length >> 16, self.length & 0xFFFF)

        return self.nb_session_header

    def smb_header(self, command):
        self.signature = b'\xffSMB'
        self.command = command
        self.error_class = 0x00
        self.zeros = 0x00
        self.error_code = 0x0000
        self.flags = 0x18
        self.flags2 = 0x0148
        self.pid_high = 0x0000
        self.security_sig = 0x0000000000000000
        self.reserved = 0x0000
        self.tid = 0xffff
        self.pid = 0xD722
        self.uid = 0x0000
        self.mid = 0x0000

        # self.smb_header_pack=pack("!HHBBH6s4s6s4s", self.htype, self.ptype, self.hlen, self.plen, self.operation, self.source_mac, self.s_ip, self.dest_mac, self.d_ip)
        self.smb_header_pack=pack("!4sBBBHBHHQHHHHH", self.signature, self.command, self.error_class, self.zeros, self.error_code, self.flags, self.flags2, self.pid_high, self.security_sig, self.reserved, self.tid, self.pid, self.uid, self.mid)
        # print(self.smb_header_pack)
        # print(binascii.hexlify(self.smb_header_pack))
        return self.smb_header_pack

    def negotiate_protocol_request(self):

        self.word_count = 0x00
        self.byte_count = 0x0C00
        self.requested_dialect = SMB_DIALECT

        self.smb_npr = pack("!BH12s", self.word_count,self.byte_count, self.requested_dialect)
        # print(self.smb_npr)
        # print(binascii.hexlify(self.smb_npr))
        return self.smb_npr

    def session_setup_andx_request_header(self):
        self.word_count = 0x0C
        self.andx_command = 0xFF
        self.reserved_1 = 0x00
        self.andx_offset = 0x0000
        self.max_buffer = 0x00F0
        self.max_mpx_count = 0x0200
        self.vc_number = 0x0100
        self.session_key = 0x00000000
        self.security_blob_length = 0x4200
        self.reserved_2 = 0x00000000
        self.capabilities = CAP_EXTENDED_SECURITY | CAP_USE_NT_ERRORS | CAP_UNICODE | CAP_LARGE_READX | CAP_LARGE_WRITEX
        self.byte_count = 0x4D00

        self.header_1 = pack('!BBBHHHHIHI', self.word_count, self.andx_command, self.reserved_1, self.andx_offset, self.max_buffer, self.max_mpx_count,
                                self.vc_number, self.session_key, self.security_blob_length, self.reserved_2) + pack('<I',self.capabilities) + pack('!H',self.byte_count)

        # print(binascii.hexlify(self.header_1))

        self.neg_token_init = GSS_API_SPNEGO_UUID
        self.mech_types = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']
                

        # MECH Token
        self.ntlm_ssp_id = b'NTLMSSP\x00'
        self.ntlm_msg_type = NTLMSSP_NEGOTIATE

        self.neg_flags = 0
        self.neg_flags |= NTLMSSP_NEGOTIATE_TARGET_INFO
        self.neg_flags |= NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | NTLMSSP_NEGOTIATE_UNICODE | \
                     NTLMSSP_REQUEST_TARGET |  NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_56

        self.workstation = 0x0000000000000000
        self.domain = 0x0000000000000000

        self.mech_token = pack("!8s",self.ntlm_ssp_id)
        self.mech_token += pack("<L",self.ntlm_msg_type)
        self.mech_token += pack("<L",self.neg_flags)
        self.mech_token += pack("!Q",self.workstation)
        self.mech_token += pack("!Q",self.domain)
        
        self.native_os = b'Unix\x00'
        self.native_lan_man = b'Samba\x00'
        
        self.header_2 = b'\x60\x40\x06\x06' + pack('!6s',self.neg_token_init) + b'\xa0\x36\x30\x34\xa0\x0e\x30\x0c\x06\x0a' + pack('!10s',self.mech_types) + b'\xa2\x22\x04\x20' + self.mech_token + pack('!5s6s', self.native_os, self.native_lan_man)


        return self.header_1 + self.header_2
        # print(binascii.hexlify(self.final_header))
        # self.security_blob = 0
        # self.native_os = 0
        # self.native_lan_manager = 0
        # ByteField("WordCount", 13),
        #            ByteEnumField("AndXCommand", 0x75, {0x75: "SMB_COM_TREE_CONNECT_ANDX"}),  # noqa: E501
        #            ByteField("Reserved2", 0),
        #            LEShortField("AndXOffset", 96),
        #            LEShortField("MaxBufferS", 2920),
        #            LEShortField("MaxMPXCount", 50),
        #            LEShortField("VCNumber", 0),
        #            LEIntField("SessionKey", 0),
        #            LEFieldLenField("ANSIPasswordLength", None, "ANSIPassword"),
        #            LEShortField("UnicodePasswordLength", 0),
        #            LEIntField("Reserved3", 0),
        #            LEShortField("ServerCapabilities", 0x05),
        #            BitField("UnixExtensions", 0, 1),
        #            BitField("Reserved4", 0, 7),
        #            BitField("ExtendedSecurity", 0, 1),
        #            BitField("CompBulk", 0, 2),
        #            BitField("Reserved5", 0, 5),
        #            LEShortField("ByteCount", 35),
        #            StrLenField("ANSIPassword", "Pass", length_from=lambda x: x.ANSIPasswordLength),  # noqa: E501
        #            StrNullField("Account", "GUEST"),
        #            StrNullField("PrimaryDomain", ""),
        #            StrNullField("NativeOS", "Windows 4.0"),
        #            StrNullField("NativeLanManager", "Windows 4.0"),
        #            ByteField("WordCount2", 4),
        #            ByteEnumField("AndXCommand2", 0xFF, {0xFF: "SMB_COM_NONE"}),
        #            ByteField("Reserved6", 0),
        #            LEShortField("AndXOffset2", 0),
        #            LEShortField("Flags3", 0x2),
        #            LEShortField("PasswordLength", 0x1),
        #            LEShortField("ByteCount2", 18),
        #            ByteField("Password", 0),
        #            StrNullField("Path", "\\\\WIN2K\\IPC$"),
        #            StrNullField("Service", "IPC")]
    def send_icmp_packet(self, packet, dest_ip):
            ICMP_CODE=socket.getprotobyname('icmp')       
            s=socket.socket(socket.AF_INET,socket.SOCK_RAW,ICMP_CODE)
            s.sendto(packet,(dest_ip,0))
            ready=select.select([s],[],[],2)
            if ready[0] == []:
                print(dest_ip + ' timeout')

            else:
                data = s.recv(1024)
                return data
            s.close()

    def send_tcp_packet(self, packet, dest_ip, port_num, sock):
        
        sock.sendto(packet,(dest_ip,0))
        # sock.settimeout(2)
        # sock.setblocking(0)
        t_end = time.time() + self.time_out
        while True:
            current_time = time.time()
            try:
                response = sock.recvfrom(1024)
                packet_data = response[0]

                response_hex = (codecs.encode(packet_data, 'hex').decode())
                recieved_from_port = response_hex[40:44]
                sent_to_port = port_num
                
                # print(recieved_from_port)
                # print(sent_to_port)
                # print(port[44:48])
                # str(int(hex_response[40:44], 16)

                recieved_from = response[1][0]
                if recieved_from == dest_ip and sent_to_port == recieved_from_port:
                    return packet_data
                    
                if current_time > t_end:
                    # print(str(int(str(port_num),16)) + " timed out.")
                    return False
            
            except socket.timeout:
                return False

    def send_arp_request(self, curr_iface, arp_packet, dest_host):

        sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))
        # sock.setblocking(0)
        sock.bind((curr_iface,socket.SOCK_RAW))
        sock.send(arp_packet)
        sock.settimeout(2)
        
        t_end = time.time() + self.time_out
        while True:
            current_time = time.time()
            try:
                response = sock.recvfrom(1024)

                packet_data = response[0]
                ip_addr = (codecs.encode(packet_data[28:32], 'hex').decode())
                ip_addr = int(ip_addr, 16)
                ip_addr = socket.inet_ntoa(struct.pack(">L", ip_addr))

                if ip_addr == dest_host:
                    return packet_data

                if current_time > t_end:
                        return

            except socket.timeout:
                return
            
            except Exception as e:
                print(e)
                pass
        
        

