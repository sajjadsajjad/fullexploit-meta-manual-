import struct
import socket
import time
import ipaddress

time_out = 2

def generate_mdns_header(dest_ip):
    t_id = 0x0000
    flags = 0x0000
    questions = 0x0001
    answer_rrs = 0x0000
    authority_rrs = 0x0000
    additional_rrs = 0x0000
    name = ipaddress.ip_address(dest_ip).reverse_pointer.encode()
    name_len = len(name)
    type_ = 0x000c
    class_ = 0x0001
    mdns_header_1 = struct.pack('!HHHHHH', t_id, flags, questions, answer_rrs, authority_rrs, additional_rrs)
    
    name_list = name.split(b'.')
    pack_format = '!{0}p{1}p{2}p{3}p{4}p{5}px'.format(len(name_list[0])+1,len(name_list[1])+1,len(name_list[2])+1,len(name_list[3])+1,len(name_list[4])+1,len(name_list[5])+1)
    mdns_header_2 = (struct.pack(pack_format,name_list[0], name_list[1],name_list[2], name_list[3],name_list[4], name_list[5]))
    
    mdns_header_3 = struct.pack('!HH', type_, class_)

    return mdns_header_1 + mdns_header_2 + mdns_header_3


def parse_mdns_response(packet_response):
    x = 0
    ip_header = packet_response[x:x+20]

    x += 20
    udp_header = packet_response[x:x+8]
    
    x += 8
    mdns_response_header = packet_response[x:]

    i = 0
    mdns_response_data_1 = mdns_response_header[i:i+12]

    i += 12
    name = mdns_response_header[i:i+28]

    i += 28
    type_ = mdns_response_header[i:i+2]

    i += 2
    class_ = mdns_response_header[i:i+2]

    i += 2
    ttl = mdns_response_header[i:i+4]

    i += 4
    data_length = mdns_response_header[i:i+2]

    data_length = int.from_bytes(data_length, byteorder='big')

    i += 2
    domain_name = mdns_response_header[i:i+data_length]

    domain_name = domain_name.split(b'local')[0].decode().strip()

    return domain_name


def send_mdns_udp_packet(packet, dest_ip, dest_ip_1, port_num, sock):
    sock.sendto(packet,(dest_ip_1, port_num))
    t_end = time.time() + time_out
    while True:
        current_time = time.time()
        try:
            response = sock.recvfrom(1024)
            packet_data = response[0]

            recieved_from_port = int.from_bytes(packet_data[20:22], byteorder='big')
            sent_to_port = port_num

            recieved_from = response[1][0]
            if recieved_from == dest_ip and sent_to_port == recieved_from_port:
                return packet_data
                
            if current_time > t_end:
                return False
        
        except socket.timeout:
            return False