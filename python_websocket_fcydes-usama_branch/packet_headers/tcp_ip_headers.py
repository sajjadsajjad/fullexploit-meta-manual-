import binascii
import select
import socket
from struct import *
import time
import struct
import codecs

class Packet:

    def __init__(self):
        self.time_out = 0.5

    def generateIPHeader(self,s_ip,d_ip):
        #IP Header
        self.version=0x4
        self.ihl=0x5
        self.type_of_service=0x0
        self.total_length=0x28
        self.identification=0x0001
        self.flags=0x0
        self.fragment_offset=0x0
        self.ttl=0x40
        self.protocol=0x6
        self.header_checksum=0x0
        self.src_ip=s_ip
        self.dest_ip=d_ip
        
        self.src_addr=socket.inet_aton(self.src_ip)
        self.dest_addr=socket.inet_aton(self.dest_ip)
        
        self.version_ihl=((self.version<<4)+self.ihl)
        self.f_fo=((self.flags<<13)+self.fragment_offset)
        self.v_ihl_tos=(self.version<<12)+(self.ihl<<8)+self.type_of_service
        self.ttl_proto=(self.ttl<<8)+self.protocol
        octets=self.src_ip.split('.')
        num1=int(octets[0])
        num2=int(octets[1])
        num3=int(octets[2])
        num4=int(octets[3])
        self.src_addr1=(num1<<8)+num2
        self.src_addr2=(num3<<8)+num4

        octets=self.dest_ip.split('.')
        num1=int(octets[0])
        num2=int(octets[1])
        num3=int(octets[2])
        num4=int(octets[3])
        self.dest_addr1=(num1<<8)+num2
        self.dest_addr2=(num3<<8)+num4

        subtotal=self.v_ihl_tos+self.total_length+self.identification+self.f_fo+self.ttl_proto+self.src_addr1+self.src_addr2+self.dest_addr1+self.dest_addr2
        self.header_checksum=(0xffff)-((subtotal>>16)+(subtotal & 0xffff))
        self.ip_header=pack("!BBHHHBBH4s4s",self.version_ihl,self.type_of_service,self.total_length,self.identification
                                ,self.f_fo,self.ttl,self.protocol,self.header_checksum,self.src_addr,self.dest_addr)

        return self.ip_header
        

    def generateTCPHeader(self,s_port,d_port, ns=0x0,cwr=0x0,ece=0x0,urg=0x0,ack=0x0,psh=0x0,rst=0x0,syn=0x0,fin=0x0):
        #TCP Segment
        self.tcp_protocol=0x6
        self.tcp_length=0x14
        self.src_port=int(s_port)
        self.dest_port=int(d_port)
        self.seq_no=0x0
        self.ack_no=0x0
        self.data_offset=0x5
        self.reserved=0x0
        self.ns=ns
        self.cwr=cwr
        self.ece=ece
        self.urg=urg
        self.ack=ack
        self.psh=psh
        self.rst=rst
        self.syn=syn
        self.fin=fin
        
        self.window_size=0x7110
        self.checksum=0x0
        self.urg_pointer=0x0
        self.data_offset_res_flags=(self.data_offset<<12)+(self.reserved<<9)+(self.ns<<8)+(self.cwr<<7)+(self.ece<<6)+(self.urg<<5)+(self.ack<<4)+(self.psh<<3)+(self.rst<<2)+(self.syn<<1)+self.fin
        tcp_subtotal=self.tcp_protocol+self.src_addr1+self.src_addr2+self.dest_addr1+self.dest_addr2+self.tcp_length+self.src_port+self.dest_port+self.seq_no+self.ack_no+self.data_offset_res_flags+self.window_size+self.urg_pointer
        self.checksum=(0xffff)-((tcp_subtotal>>16)+(tcp_subtotal & 0xffff))
    
        
        try:
            self.tcp_header=pack("!HHLLHHHH",self.src_port,self.dest_port,self.seq_no,self.ack_no,self.data_offset_res_flags,
                        self.window_size,self.checksum,self.urg_pointer)
        except Exception as e:
            pass
        return self.tcp_header
        
    def generateICMPHeader(self, identifier):

        #########################################
        #|Type      |Code       |Checksum       |
        #|(8bits)   |(8bits)    |(16bits)       |
        #----------------------------------------
        #|Identifier      |Checksum             |       
        #|(16bits)        |(16bits)             |
        #########################################

        self.type=0x8
        self.code=0x0
        self.checksum=0x0
        self.own_id=identifier
        self.seq_number=0x0

        self.type_code=(self.type<<8)+self.code
        icmp_subtotal=self.type_code+self.checksum+self.own_id+self.seq_number
        self.checksum=(0xffff)-((icmp_subtotal>>16)+(icmp_subtotal & 0xffff))
        
        icmp_header =pack("!BBHHH", self.type, self.code, self.checksum, self.own_id, self.seq_number)
        return icmp_header
    
    
    def generateARPHeader(self, source_mac, source_ip,dest_ip):
        
        #Ethernet Header
        self.source_mac=binascii.unhexlify(source_mac.replace(':','')) 
        self.dest_mac=b'\xff\xff\xff\xff\xff\xff' 
        self.protocol=0x0806
        self.eth_header=pack("!6s6sH", self.dest_mac,self.source_mac,self.protocol)

        #ARP Header
        self.source_ip=source_ip
        self.dest_ip=dest_ip
        self.htype=1
        self.ptype=0x0800
        self.hlen=6
        self.plen=4
        self.operation=1
        self.s_ip=socket.inet_aton(self.source_ip)
        self.d_ip=socket.inet_aton(self.dest_ip)
        self.dest_mac=b'\x00\x00\x00\x00\x00\x00'
        self.arp_header=pack("!HHBBH6s4s6s4s", self.htype, self.ptype, self.hlen, self.plen, self.operation, self.source_mac, self.s_ip, self.dest_mac, self.d_ip)

        arp_packet = self.eth_header + self.arp_header

        return arp_packet

    def send_icmp_packet(self, packet, dest_ip, sock):
        # ICMP_CODE = socket.getprotobyname('icmp')       
        # sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, ICMP_CODE)
        # sock.sendto(packet,(dest_ip,0))
        # ready=select.select([sock],[],[],2)
        # if ready[0] == []:
        #     print(dest_ip + ' timeout')

        # else:
        #     data = sock.recvfrom(1024)
        #     print(data)
        #     return data
        # sock.close()
        sock.sendto(packet, (dest_ip, 0))
        t_end = time.time() + self.time_out
        while True:
            current_time = time.time()
            try:
                response = sock.recvfrom(1024)
                packet_data = response[0]
                recieved_from = response[1][0]
                if recieved_from == dest_ip:
                    return packet_data
                        
                if current_time > t_end:
                    return False
            except socket.timeout:
                return False

    def send_tcp_packet(self, packet, dest_ip, port_num, sock):
        
        sock.sendto(packet,(dest_ip,0))
        # sock.settimeout(2)
        # sock.setblocking(0)
        t_end = time.time() + self.time_out
        while True:
            current_time = time.time()
            try:
                response = sock.recvfrom(1024)
                packet_data = response[0]

                response_hex = (codecs.encode(packet_data, 'hex').decode())
                recieved_from_port = response_hex[40:44]
                sent_to_port = port_num
                
                # print(recieved_from_port)
                # print(sent_to_port)
                # print(port[44:48])
                # str(int(hex_response[40:44], 16)

                recieved_from = response[1][0]
                if recieved_from == dest_ip and sent_to_port == recieved_from_port:
                    return packet_data
                    
                if current_time > t_end:
                    # print(str(int(str(port_num),16)) + " timed out.")
                    return False
            
            except socket.timeout:
                return False

    def send_arp_request(self, curr_iface, arp_packet, dest_host):

        sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))
        # sock.setblocking(0)
        sock.bind((curr_iface,socket.SOCK_RAW))
        sock.send(arp_packet)
        sock.settimeout(2)
        
        t_end = time.time() + self.time_out
        while True:
            current_time = time.time()
            try:
                response = sock.recvfrom(1024)

                packet_data = response[0]
                ip_addr = (codecs.encode(packet_data[28:32], 'hex').decode())
                ip_addr = int(ip_addr, 16)
                ip_addr = socket.inet_ntoa(struct.pack(">L", ip_addr))

                if ip_addr == dest_host:
                    return packet_data

                if current_time > t_end:
                        return

            except socket.timeout:
                return
            
            except Exception as e:
                print(e)
                pass
        
        
